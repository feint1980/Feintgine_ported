// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: objectData.proto

#ifndef PROTOBUF_objectData_2eproto__INCLUDED
#define PROTOBUF_objectData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_objectData_2eproto();
void protobuf_AssignDesc_objectData_2eproto();
void protobuf_ShutdownFile_objectData_2eproto();

class Proc_Vec2;
class Proc_Vec3;
class Proc_Vec4;
class Proc_SpotLight;
class Proc_ColiderBox;
class Proc_Sprite;
class Proc_OwnSprite;
class Proc_Object;
class Proc_LoadObject;
class Proc_Brush;
class Proc_Layer;
class Proc_Scene;

// ===================================================================

class Proc_Vec2 : public ::google::protobuf::Message {
 public:
  Proc_Vec2();
  virtual ~Proc_Vec2();

  Proc_Vec2(const Proc_Vec2& from);

  inline Proc_Vec2& operator=(const Proc_Vec2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Vec2& default_instance();

  void Swap(Proc_Vec2* other);

  // implements Message ----------------------------------------------

  Proc_Vec2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Vec2& from);
  void MergeFrom(const Proc_Vec2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float valueX = 1;
  inline bool has_valuex() const;
  inline void clear_valuex();
  static const int kValueXFieldNumber = 1;
  inline float valuex() const;
  inline void set_valuex(float value);

  // required float valueY = 2;
  inline bool has_valuey() const;
  inline void clear_valuey();
  static const int kValueYFieldNumber = 2;
  inline float valuey() const;
  inline void set_valuey(float value);

  // @@protoc_insertion_point(class_scope:Proc_Vec2)
 private:
  inline void set_has_valuex();
  inline void clear_has_valuex();
  inline void set_has_valuey();
  inline void clear_has_valuey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float valuex_;
  float valuey_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Vec2* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Vec3 : public ::google::protobuf::Message {
 public:
  Proc_Vec3();
  virtual ~Proc_Vec3();

  Proc_Vec3(const Proc_Vec3& from);

  inline Proc_Vec3& operator=(const Proc_Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Vec3& default_instance();

  void Swap(Proc_Vec3* other);

  // implements Message ----------------------------------------------

  Proc_Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Vec3& from);
  void MergeFrom(const Proc_Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float valueX = 1;
  inline bool has_valuex() const;
  inline void clear_valuex();
  static const int kValueXFieldNumber = 1;
  inline float valuex() const;
  inline void set_valuex(float value);

  // required float valueY = 2;
  inline bool has_valuey() const;
  inline void clear_valuey();
  static const int kValueYFieldNumber = 2;
  inline float valuey() const;
  inline void set_valuey(float value);

  // required float valueZ = 3;
  inline bool has_valuez() const;
  inline void clear_valuez();
  static const int kValueZFieldNumber = 3;
  inline float valuez() const;
  inline void set_valuez(float value);

  // @@protoc_insertion_point(class_scope:Proc_Vec3)
 private:
  inline void set_has_valuex();
  inline void clear_has_valuex();
  inline void set_has_valuey();
  inline void clear_has_valuey();
  inline void set_has_valuez();
  inline void clear_has_valuez();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float valuex_;
  float valuey_;
  float valuez_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Vec4 : public ::google::protobuf::Message {
 public:
  Proc_Vec4();
  virtual ~Proc_Vec4();

  Proc_Vec4(const Proc_Vec4& from);

  inline Proc_Vec4& operator=(const Proc_Vec4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Vec4& default_instance();

  void Swap(Proc_Vec4* other);

  // implements Message ----------------------------------------------

  Proc_Vec4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Vec4& from);
  void MergeFrom(const Proc_Vec4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float valueX = 1;
  inline bool has_valuex() const;
  inline void clear_valuex();
  static const int kValueXFieldNumber = 1;
  inline float valuex() const;
  inline void set_valuex(float value);

  // required float valueY = 2;
  inline bool has_valuey() const;
  inline void clear_valuey();
  static const int kValueYFieldNumber = 2;
  inline float valuey() const;
  inline void set_valuey(float value);

  // required float valueZ = 3;
  inline bool has_valuez() const;
  inline void clear_valuez();
  static const int kValueZFieldNumber = 3;
  inline float valuez() const;
  inline void set_valuez(float value);

  // required float valueW = 4;
  inline bool has_valuew() const;
  inline void clear_valuew();
  static const int kValueWFieldNumber = 4;
  inline float valuew() const;
  inline void set_valuew(float value);

  // @@protoc_insertion_point(class_scope:Proc_Vec4)
 private:
  inline void set_has_valuex();
  inline void clear_has_valuex();
  inline void set_has_valuey();
  inline void clear_has_valuey();
  inline void set_has_valuez();
  inline void clear_has_valuez();
  inline void set_has_valuew();
  inline void clear_has_valuew();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float valuex_;
  float valuey_;
  float valuez_;
  float valuew_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Vec4* default_instance_;
};
// -------------------------------------------------------------------

class Proc_SpotLight : public ::google::protobuf::Message {
 public:
  Proc_SpotLight();
  virtual ~Proc_SpotLight();

  Proc_SpotLight(const Proc_SpotLight& from);

  inline Proc_SpotLight& operator=(const Proc_SpotLight& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_SpotLight& default_instance();

  void Swap(Proc_SpotLight* other);

  // implements Message ----------------------------------------------

  Proc_SpotLight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_SpotLight& from);
  void MergeFrom(const Proc_SpotLight& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proc_Vec2 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::Proc_Vec2& pos() const;
  inline ::Proc_Vec2* mutable_pos();
  inline ::Proc_Vec2* release_pos();
  inline void set_allocated_pos(::Proc_Vec2* pos);

  // required .Proc_Vec4 color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::Proc_Vec4& color() const;
  inline ::Proc_Vec4* mutable_color();
  inline ::Proc_Vec4* release_color();
  inline void set_allocated_color(::Proc_Vec4* color);

  // required .Proc_Vec3 atenuation = 3;
  inline bool has_atenuation() const;
  inline void clear_atenuation();
  static const int kAtenuationFieldNumber = 3;
  inline const ::Proc_Vec3& atenuation() const;
  inline ::Proc_Vec3* mutable_atenuation();
  inline ::Proc_Vec3* release_atenuation();
  inline void set_allocated_atenuation(::Proc_Vec3* atenuation);

  // @@protoc_insertion_point(class_scope:Proc_SpotLight)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_atenuation();
  inline void clear_has_atenuation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Proc_Vec2* pos_;
  ::Proc_Vec4* color_;
  ::Proc_Vec3* atenuation_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_SpotLight* default_instance_;
};
// -------------------------------------------------------------------

class Proc_ColiderBox : public ::google::protobuf::Message {
 public:
  Proc_ColiderBox();
  virtual ~Proc_ColiderBox();

  Proc_ColiderBox(const Proc_ColiderBox& from);

  inline Proc_ColiderBox& operator=(const Proc_ColiderBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_ColiderBox& default_instance();

  void Swap(Proc_ColiderBox* other);

  // implements Message ----------------------------------------------

  Proc_ColiderBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_ColiderBox& from);
  void MergeFrom(const Proc_ColiderBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proc_Vec2 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::Proc_Vec2& pos() const;
  inline ::Proc_Vec2* mutable_pos();
  inline ::Proc_Vec2* release_pos();
  inline void set_allocated_pos(::Proc_Vec2* pos);

  // required .Proc_Vec2 dim = 2;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline const ::Proc_Vec2& dim() const;
  inline ::Proc_Vec2* mutable_dim();
  inline ::Proc_Vec2* release_dim();
  inline void set_allocated_dim(::Proc_Vec2* dim);

  // @@protoc_insertion_point(class_scope:Proc_ColiderBox)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_dim();
  inline void clear_has_dim();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Proc_Vec2* pos_;
  ::Proc_Vec2* dim_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_ColiderBox* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Sprite : public ::google::protobuf::Message {
 public:
  Proc_Sprite();
  virtual ~Proc_Sprite();

  Proc_Sprite(const Proc_Sprite& from);

  inline Proc_Sprite& operator=(const Proc_Sprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Sprite& default_instance();

  void Swap(Proc_Sprite* other);

  // implements Message ----------------------------------------------

  Proc_Sprite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Sprite& from);
  void MergeFrom(const Proc_Sprite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string texturePath = 1;
  inline bool has_texturepath() const;
  inline void clear_texturepath();
  static const int kTexturePathFieldNumber = 1;
  inline const ::std::string& texturepath() const;
  inline void set_texturepath(const ::std::string& value);
  inline void set_texturepath(const char* value);
  inline void set_texturepath(const char* value, size_t size);
  inline ::std::string* mutable_texturepath();
  inline ::std::string* release_texturepath();
  inline void set_allocated_texturepath(::std::string* texturepath);

  // required .Proc_Vec2 dim = 2;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline const ::Proc_Vec2& dim() const;
  inline ::Proc_Vec2* mutable_dim();
  inline ::Proc_Vec2* release_dim();
  inline void set_allocated_dim(::Proc_Vec2* dim);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string packetName = 4;
  inline bool has_packetname() const;
  inline void clear_packetname();
  static const int kPacketNameFieldNumber = 4;
  inline const ::std::string& packetname() const;
  inline void set_packetname(const ::std::string& value);
  inline void set_packetname(const char* value);
  inline void set_packetname(const char* value, size_t size);
  inline ::std::string* mutable_packetname();
  inline ::std::string* release_packetname();
  inline void set_allocated_packetname(::std::string* packetname);

  // @@protoc_insertion_point(class_scope:Proc_Sprite)
 private:
  inline void set_has_texturepath();
  inline void clear_has_texturepath();
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_packetname();
  inline void clear_has_packetname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* texturepath_;
  ::Proc_Vec2* dim_;
  ::std::string* name_;
  ::std::string* packetname_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Sprite* default_instance_;
};
// -------------------------------------------------------------------

class Proc_OwnSprite : public ::google::protobuf::Message {
 public:
  Proc_OwnSprite();
  virtual ~Proc_OwnSprite();

  Proc_OwnSprite(const Proc_OwnSprite& from);

  inline Proc_OwnSprite& operator=(const Proc_OwnSprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_OwnSprite& default_instance();

  void Swap(Proc_OwnSprite* other);

  // implements Message ----------------------------------------------

  Proc_OwnSprite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_OwnSprite& from);
  void MergeFrom(const Proc_OwnSprite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proc_Sprite Proc_Sprite = 1;
  inline bool has_proc_sprite() const;
  inline void clear_proc_sprite();
  static const int kProcSpriteFieldNumber = 1;
  inline const ::Proc_Sprite& proc_sprite() const;
  inline ::Proc_Sprite* mutable_proc_sprite();
  inline ::Proc_Sprite* release_proc_sprite();
  inline void set_allocated_proc_sprite(::Proc_Sprite* proc_sprite);

  // required .Proc_Vec2 offsetPos = 2;
  inline bool has_offsetpos() const;
  inline void clear_offsetpos();
  static const int kOffsetPosFieldNumber = 2;
  inline const ::Proc_Vec2& offsetpos() const;
  inline ::Proc_Vec2* mutable_offsetpos();
  inline ::Proc_Vec2* release_offsetpos();
  inline void set_allocated_offsetpos(::Proc_Vec2* offsetpos);

  // required .Proc_Vec2 offsetScale = 3;
  inline bool has_offsetscale() const;
  inline void clear_offsetscale();
  static const int kOffsetScaleFieldNumber = 3;
  inline const ::Proc_Vec2& offsetscale() const;
  inline ::Proc_Vec2* mutable_offsetscale();
  inline ::Proc_Vec2* release_offsetscale();
  inline void set_allocated_offsetscale(::Proc_Vec2* offsetscale);

  // required .Proc_Vec4 color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline const ::Proc_Vec4& color() const;
  inline ::Proc_Vec4* mutable_color();
  inline ::Proc_Vec4* release_color();
  inline void set_allocated_color(::Proc_Vec4* color);

  // required float depth = 5;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 5;
  inline float depth() const;
  inline void set_depth(float value);

  // optional float angle = 6;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 6;
  inline float angle() const;
  inline void set_angle(float value);

  // @@protoc_insertion_point(class_scope:Proc_OwnSprite)
 private:
  inline void set_has_proc_sprite();
  inline void clear_has_proc_sprite();
  inline void set_has_offsetpos();
  inline void clear_has_offsetpos();
  inline void set_has_offsetscale();
  inline void clear_has_offsetscale();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Proc_Sprite* proc_sprite_;
  ::Proc_Vec2* offsetpos_;
  ::Proc_Vec2* offsetscale_;
  ::Proc_Vec4* color_;
  float depth_;
  float angle_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_OwnSprite* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Object : public ::google::protobuf::Message {
 public:
  Proc_Object();
  virtual ~Proc_Object();

  Proc_Object(const Proc_Object& from);

  inline Proc_Object& operator=(const Proc_Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Object& default_instance();

  void Swap(Proc_Object* other);

  // implements Message ----------------------------------------------

  Proc_Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Object& from);
  void MergeFrom(const Proc_Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Proc_OwnSprite Proc_SpriteList = 2;
  inline int proc_spritelist_size() const;
  inline void clear_proc_spritelist();
  static const int kProcSpriteListFieldNumber = 2;
  inline const ::Proc_OwnSprite& proc_spritelist(int index) const;
  inline ::Proc_OwnSprite* mutable_proc_spritelist(int index);
  inline ::Proc_OwnSprite* add_proc_spritelist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_OwnSprite >&
      proc_spritelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_OwnSprite >*
      mutable_proc_spritelist();

  // repeated .Proc_SpotLight lightList = 3;
  inline int lightlist_size() const;
  inline void clear_lightlist();
  static const int kLightListFieldNumber = 3;
  inline const ::Proc_SpotLight& lightlist(int index) const;
  inline ::Proc_SpotLight* mutable_lightlist(int index);
  inline ::Proc_SpotLight* add_lightlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_SpotLight >&
      lightlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_SpotLight >*
      mutable_lightlist();

  // repeated .Proc_ColiderBox coliderList = 4;
  inline int coliderlist_size() const;
  inline void clear_coliderlist();
  static const int kColiderListFieldNumber = 4;
  inline const ::Proc_ColiderBox& coliderlist(int index) const;
  inline ::Proc_ColiderBox* mutable_coliderlist(int index);
  inline ::Proc_ColiderBox* add_coliderlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_ColiderBox >&
      coliderlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_ColiderBox >*
      mutable_coliderlist();

  // @@protoc_insertion_point(class_scope:Proc_Object)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Proc_OwnSprite > proc_spritelist_;
  ::google::protobuf::RepeatedPtrField< ::Proc_SpotLight > lightlist_;
  ::google::protobuf::RepeatedPtrField< ::Proc_ColiderBox > coliderlist_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Object* default_instance_;
};
// -------------------------------------------------------------------

class Proc_LoadObject : public ::google::protobuf::Message {
 public:
  Proc_LoadObject();
  virtual ~Proc_LoadObject();

  Proc_LoadObject(const Proc_LoadObject& from);

  inline Proc_LoadObject& operator=(const Proc_LoadObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_LoadObject& default_instance();

  void Swap(Proc_LoadObject* other);

  // implements Message ----------------------------------------------

  Proc_LoadObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_LoadObject& from);
  void MergeFrom(const Proc_LoadObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Proc_Object refab = 1;
  inline bool has_refab() const;
  inline void clear_refab();
  static const int kRefabFieldNumber = 1;
  inline const ::Proc_Object& refab() const;
  inline ::Proc_Object* mutable_refab();
  inline ::Proc_Object* release_refab();
  inline void set_allocated_refab(::Proc_Object* refab);

  // required .Proc_Vec2 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::Proc_Vec2& pos() const;
  inline ::Proc_Vec2* mutable_pos();
  inline ::Proc_Vec2* release_pos();
  inline void set_allocated_pos(::Proc_Vec2* pos);

  // required .Proc_Vec4 color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::Proc_Vec4& color() const;
  inline ::Proc_Vec4* mutable_color();
  inline ::Proc_Vec4* release_color();
  inline void set_allocated_color(::Proc_Vec4* color);

  // required float angle = 4;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 4;
  inline float angle() const;
  inline void set_angle(float value);

  // required .Proc_Vec2 scale = 5;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 5;
  inline const ::Proc_Vec2& scale() const;
  inline ::Proc_Vec2* mutable_scale();
  inline ::Proc_Vec2* release_scale();
  inline void set_allocated_scale(::Proc_Vec2* scale);

  // @@protoc_insertion_point(class_scope:Proc_LoadObject)
 private:
  inline void set_has_refab();
  inline void clear_has_refab();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Proc_Object* refab_;
  ::Proc_Vec2* pos_;
  ::Proc_Vec4* color_;
  ::Proc_Vec2* scale_;
  float angle_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_LoadObject* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Brush : public ::google::protobuf::Message {
 public:
  Proc_Brush();
  virtual ~Proc_Brush();

  Proc_Brush(const Proc_Brush& from);

  inline Proc_Brush& operator=(const Proc_Brush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Brush& default_instance();

  void Swap(Proc_Brush* other);

  // implements Message ----------------------------------------------

  Proc_Brush* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Brush& from);
  void MergeFrom(const Proc_Brush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string textureName = 1;
  inline bool has_texturename() const;
  inline void clear_texturename();
  static const int kTextureNameFieldNumber = 1;
  inline const ::std::string& texturename() const;
  inline void set_texturename(const ::std::string& value);
  inline void set_texturename(const char* value);
  inline void set_texturename(const char* value, size_t size);
  inline ::std::string* mutable_texturename();
  inline ::std::string* release_texturename();
  inline void set_allocated_texturename(::std::string* texturename);

  // required .Proc_Vec2 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::Proc_Vec2& pos() const;
  inline ::Proc_Vec2* mutable_pos();
  inline ::Proc_Vec2* release_pos();
  inline void set_allocated_pos(::Proc_Vec2* pos);

  // required .Proc_Vec2 dim = 3;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 3;
  inline const ::Proc_Vec2& dim() const;
  inline ::Proc_Vec2* mutable_dim();
  inline ::Proc_Vec2* release_dim();
  inline void set_allocated_dim(::Proc_Vec2* dim);

  // required .Proc_Vec2 uv = 4;
  inline bool has_uv() const;
  inline void clear_uv();
  static const int kUvFieldNumber = 4;
  inline const ::Proc_Vec2& uv() const;
  inline ::Proc_Vec2* mutable_uv();
  inline ::Proc_Vec2* release_uv();
  inline void set_allocated_uv(::Proc_Vec2* uv);

  // required float depth = 5;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 5;
  inline float depth() const;
  inline void set_depth(float value);

  // @@protoc_insertion_point(class_scope:Proc_Brush)
 private:
  inline void set_has_texturename();
  inline void clear_has_texturename();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_uv();
  inline void clear_has_uv();
  inline void set_has_depth();
  inline void clear_has_depth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* texturename_;
  ::Proc_Vec2* pos_;
  ::Proc_Vec2* dim_;
  ::Proc_Vec2* uv_;
  float depth_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Brush* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Layer : public ::google::protobuf::Message {
 public:
  Proc_Layer();
  virtual ~Proc_Layer();

  Proc_Layer(const Proc_Layer& from);

  inline Proc_Layer& operator=(const Proc_Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Layer& default_instance();

  void Swap(Proc_Layer* other);

  // implements Message ----------------------------------------------

  Proc_Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Layer& from);
  void MergeFrom(const Proc_Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 depth = 2;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 2;
  inline ::google::protobuf::int32 depth() const;
  inline void set_depth(::google::protobuf::int32 value);

  // repeated .Proc_LoadObject objectList = 3;
  inline int objectlist_size() const;
  inline void clear_objectlist();
  static const int kObjectListFieldNumber = 3;
  inline const ::Proc_LoadObject& objectlist(int index) const;
  inline ::Proc_LoadObject* mutable_objectlist(int index);
  inline ::Proc_LoadObject* add_objectlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_LoadObject >&
      objectlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_LoadObject >*
      mutable_objectlist();

  // repeated .Proc_Brush brushList = 4;
  inline int brushlist_size() const;
  inline void clear_brushlist();
  static const int kBrushListFieldNumber = 4;
  inline const ::Proc_Brush& brushlist(int index) const;
  inline ::Proc_Brush* mutable_brushlist(int index);
  inline ::Proc_Brush* add_brushlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_Brush >&
      brushlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_Brush >*
      mutable_brushlist();

  // @@protoc_insertion_point(class_scope:Proc_Layer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_depth();
  inline void clear_has_depth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Proc_LoadObject > objectlist_;
  ::google::protobuf::RepeatedPtrField< ::Proc_Brush > brushlist_;
  ::google::protobuf::int32 depth_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Layer* default_instance_;
};
// -------------------------------------------------------------------

class Proc_Scene : public ::google::protobuf::Message {
 public:
  Proc_Scene();
  virtual ~Proc_Scene();

  Proc_Scene(const Proc_Scene& from);

  inline Proc_Scene& operator=(const Proc_Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proc_Scene& default_instance();

  void Swap(Proc_Scene* other);

  // implements Message ----------------------------------------------

  Proc_Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proc_Scene& from);
  void MergeFrom(const Proc_Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Proc_Layer layerList = 2;
  inline int layerlist_size() const;
  inline void clear_layerlist();
  static const int kLayerListFieldNumber = 2;
  inline const ::Proc_Layer& layerlist(int index) const;
  inline ::Proc_Layer* mutable_layerlist(int index);
  inline ::Proc_Layer* add_layerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::Proc_Layer >&
      layerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Proc_Layer >*
      mutable_layerlist();

  // @@protoc_insertion_point(class_scope:Proc_Scene)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Proc_Layer > layerlist_;
  friend void  protobuf_AddDesc_objectData_2eproto();
  friend void protobuf_AssignDesc_objectData_2eproto();
  friend void protobuf_ShutdownFile_objectData_2eproto();

  void InitAsDefaultInstance();
  static Proc_Scene* default_instance_;
};
// ===================================================================


// ===================================================================

// Proc_Vec2

// required float valueX = 1;
inline bool Proc_Vec2::has_valuex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Vec2::set_has_valuex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Vec2::clear_has_valuex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Vec2::clear_valuex() {
  valuex_ = 0;
  clear_has_valuex();
}
inline float Proc_Vec2::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec2.valueX)
  return valuex_;
}
inline void Proc_Vec2::set_valuex(float value) {
  set_has_valuex();
  valuex_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec2.valueX)
}

// required float valueY = 2;
inline bool Proc_Vec2::has_valuey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Vec2::set_has_valuey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Vec2::clear_has_valuey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Vec2::clear_valuey() {
  valuey_ = 0;
  clear_has_valuey();
}
inline float Proc_Vec2::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec2.valueY)
  return valuey_;
}
inline void Proc_Vec2::set_valuey(float value) {
  set_has_valuey();
  valuey_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec2.valueY)
}

// -------------------------------------------------------------------

// Proc_Vec3

// required float valueX = 1;
inline bool Proc_Vec3::has_valuex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Vec3::set_has_valuex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Vec3::clear_has_valuex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Vec3::clear_valuex() {
  valuex_ = 0;
  clear_has_valuex();
}
inline float Proc_Vec3::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueX)
  return valuex_;
}
inline void Proc_Vec3::set_valuex(float value) {
  set_has_valuex();
  valuex_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueX)
}

// required float valueY = 2;
inline bool Proc_Vec3::has_valuey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Vec3::set_has_valuey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Vec3::clear_has_valuey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Vec3::clear_valuey() {
  valuey_ = 0;
  clear_has_valuey();
}
inline float Proc_Vec3::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueY)
  return valuey_;
}
inline void Proc_Vec3::set_valuey(float value) {
  set_has_valuey();
  valuey_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueY)
}

// required float valueZ = 3;
inline bool Proc_Vec3::has_valuez() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_Vec3::set_has_valuez() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_Vec3::clear_has_valuez() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_Vec3::clear_valuez() {
  valuez_ = 0;
  clear_has_valuez();
}
inline float Proc_Vec3::valuez() const {
  // @@protoc_insertion_point(field_get:Proc_Vec3.valueZ)
  return valuez_;
}
inline void Proc_Vec3::set_valuez(float value) {
  set_has_valuez();
  valuez_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec3.valueZ)
}

// -------------------------------------------------------------------

// Proc_Vec4

// required float valueX = 1;
inline bool Proc_Vec4::has_valuex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Vec4::set_has_valuex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Vec4::clear_has_valuex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Vec4::clear_valuex() {
  valuex_ = 0;
  clear_has_valuex();
}
inline float Proc_Vec4::valuex() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueX)
  return valuex_;
}
inline void Proc_Vec4::set_valuex(float value) {
  set_has_valuex();
  valuex_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueX)
}

// required float valueY = 2;
inline bool Proc_Vec4::has_valuey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Vec4::set_has_valuey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Vec4::clear_has_valuey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Vec4::clear_valuey() {
  valuey_ = 0;
  clear_has_valuey();
}
inline float Proc_Vec4::valuey() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueY)
  return valuey_;
}
inline void Proc_Vec4::set_valuey(float value) {
  set_has_valuey();
  valuey_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueY)
}

// required float valueZ = 3;
inline bool Proc_Vec4::has_valuez() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_Vec4::set_has_valuez() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_Vec4::clear_has_valuez() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_Vec4::clear_valuez() {
  valuez_ = 0;
  clear_has_valuez();
}
inline float Proc_Vec4::valuez() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueZ)
  return valuez_;
}
inline void Proc_Vec4::set_valuez(float value) {
  set_has_valuez();
  valuez_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueZ)
}

// required float valueW = 4;
inline bool Proc_Vec4::has_valuew() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proc_Vec4::set_has_valuew() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proc_Vec4::clear_has_valuew() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proc_Vec4::clear_valuew() {
  valuew_ = 0;
  clear_has_valuew();
}
inline float Proc_Vec4::valuew() const {
  // @@protoc_insertion_point(field_get:Proc_Vec4.valueW)
  return valuew_;
}
inline void Proc_Vec4::set_valuew(float value) {
  set_has_valuew();
  valuew_ = value;
  // @@protoc_insertion_point(field_set:Proc_Vec4.valueW)
}

// -------------------------------------------------------------------

// Proc_SpotLight

// required .Proc_Vec2 pos = 1;
inline bool Proc_SpotLight::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_SpotLight::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_SpotLight::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_SpotLight::clear_pos() {
  if (pos_ != NULL) pos_->::Proc_Vec2::Clear();
  clear_has_pos();
}
inline const ::Proc_Vec2& Proc_SpotLight::pos() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Proc_Vec2* Proc_SpotLight::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.pos)
  return pos_;
}
inline ::Proc_Vec2* Proc_SpotLight::release_pos() {
  clear_has_pos();
  ::Proc_Vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Proc_SpotLight::set_allocated_pos(::Proc_Vec2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.pos)
}

// required .Proc_Vec4 color = 2;
inline bool Proc_SpotLight::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_SpotLight::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_SpotLight::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_SpotLight::clear_color() {
  if (color_ != NULL) color_->::Proc_Vec4::Clear();
  clear_has_color();
}
inline const ::Proc_Vec4& Proc_SpotLight::color() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Proc_Vec4* Proc_SpotLight::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Proc_Vec4;
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.color)
  return color_;
}
inline ::Proc_Vec4* Proc_SpotLight::release_color() {
  clear_has_color();
  ::Proc_Vec4* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Proc_SpotLight::set_allocated_color(::Proc_Vec4* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.color)
}

// required .Proc_Vec3 atenuation = 3;
inline bool Proc_SpotLight::has_atenuation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_SpotLight::set_has_atenuation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_SpotLight::clear_has_atenuation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_SpotLight::clear_atenuation() {
  if (atenuation_ != NULL) atenuation_->::Proc_Vec3::Clear();
  clear_has_atenuation();
}
inline const ::Proc_Vec3& Proc_SpotLight::atenuation() const {
  // @@protoc_insertion_point(field_get:Proc_SpotLight.atenuation)
  return atenuation_ != NULL ? *atenuation_ : *default_instance_->atenuation_;
}
inline ::Proc_Vec3* Proc_SpotLight::mutable_atenuation() {
  set_has_atenuation();
  if (atenuation_ == NULL) atenuation_ = new ::Proc_Vec3;
  // @@protoc_insertion_point(field_mutable:Proc_SpotLight.atenuation)
  return atenuation_;
}
inline ::Proc_Vec3* Proc_SpotLight::release_atenuation() {
  clear_has_atenuation();
  ::Proc_Vec3* temp = atenuation_;
  atenuation_ = NULL;
  return temp;
}
inline void Proc_SpotLight::set_allocated_atenuation(::Proc_Vec3* atenuation) {
  delete atenuation_;
  atenuation_ = atenuation;
  if (atenuation) {
    set_has_atenuation();
  } else {
    clear_has_atenuation();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_SpotLight.atenuation)
}

// -------------------------------------------------------------------

// Proc_ColiderBox

// required .Proc_Vec2 pos = 1;
inline bool Proc_ColiderBox::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_ColiderBox::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_ColiderBox::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_ColiderBox::clear_pos() {
  if (pos_ != NULL) pos_->::Proc_Vec2::Clear();
  clear_has_pos();
}
inline const ::Proc_Vec2& Proc_ColiderBox::pos() const {
  // @@protoc_insertion_point(field_get:Proc_ColiderBox.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Proc_Vec2* Proc_ColiderBox::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_ColiderBox.pos)
  return pos_;
}
inline ::Proc_Vec2* Proc_ColiderBox::release_pos() {
  clear_has_pos();
  ::Proc_Vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Proc_ColiderBox::set_allocated_pos(::Proc_Vec2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_ColiderBox.pos)
}

// required .Proc_Vec2 dim = 2;
inline bool Proc_ColiderBox::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_ColiderBox::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_ColiderBox::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_ColiderBox::clear_dim() {
  if (dim_ != NULL) dim_->::Proc_Vec2::Clear();
  clear_has_dim();
}
inline const ::Proc_Vec2& Proc_ColiderBox::dim() const {
  // @@protoc_insertion_point(field_get:Proc_ColiderBox.dim)
  return dim_ != NULL ? *dim_ : *default_instance_->dim_;
}
inline ::Proc_Vec2* Proc_ColiderBox::mutable_dim() {
  set_has_dim();
  if (dim_ == NULL) dim_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_ColiderBox.dim)
  return dim_;
}
inline ::Proc_Vec2* Proc_ColiderBox::release_dim() {
  clear_has_dim();
  ::Proc_Vec2* temp = dim_;
  dim_ = NULL;
  return temp;
}
inline void Proc_ColiderBox::set_allocated_dim(::Proc_Vec2* dim) {
  delete dim_;
  dim_ = dim;
  if (dim) {
    set_has_dim();
  } else {
    clear_has_dim();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_ColiderBox.dim)
}

// -------------------------------------------------------------------

// Proc_Sprite

// required string texturePath = 1;
inline bool Proc_Sprite::has_texturepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Sprite::set_has_texturepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Sprite::clear_has_texturepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Sprite::clear_texturepath() {
  if (texturepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_->clear();
  }
  clear_has_texturepath();
}
inline const ::std::string& Proc_Sprite::texturepath() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.texturePath)
  return *texturepath_;
}
inline void Proc_Sprite::set_texturepath(const ::std::string& value) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Sprite.texturePath)
}
inline void Proc_Sprite::set_texturepath(const char* value) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Sprite.texturePath)
}
inline void Proc_Sprite::set_texturepath(const char* value, size_t size) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Sprite.texturePath)
}
inline ::std::string* Proc_Sprite::mutable_texturepath() {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.texturePath)
  return texturepath_;
}
inline ::std::string* Proc_Sprite::release_texturepath() {
  clear_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = texturepath_;
    texturepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Sprite::set_allocated_texturepath(::std::string* texturepath) {
  if (texturepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete texturepath_;
  }
  if (texturepath) {
    set_has_texturepath();
    texturepath_ = texturepath;
  } else {
    clear_has_texturepath();
    texturepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.texturePath)
}

// required .Proc_Vec2 dim = 2;
inline bool Proc_Sprite::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Sprite::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Sprite::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Sprite::clear_dim() {
  if (dim_ != NULL) dim_->::Proc_Vec2::Clear();
  clear_has_dim();
}
inline const ::Proc_Vec2& Proc_Sprite::dim() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.dim)
  return dim_ != NULL ? *dim_ : *default_instance_->dim_;
}
inline ::Proc_Vec2* Proc_Sprite::mutable_dim() {
  set_has_dim();
  if (dim_ == NULL) dim_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.dim)
  return dim_;
}
inline ::Proc_Vec2* Proc_Sprite::release_dim() {
  clear_has_dim();
  ::Proc_Vec2* temp = dim_;
  dim_ = NULL;
  return temp;
}
inline void Proc_Sprite::set_allocated_dim(::Proc_Vec2* dim) {
  delete dim_;
  dim_ = dim;
  if (dim) {
    set_has_dim();
  } else {
    clear_has_dim();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.dim)
}

// required string name = 3;
inline bool Proc_Sprite::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_Sprite::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_Sprite::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_Sprite::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Proc_Sprite::name() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.name)
  return *name_;
}
inline void Proc_Sprite::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Sprite.name)
}
inline void Proc_Sprite::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Sprite.name)
}
inline void Proc_Sprite::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Sprite.name)
}
inline ::std::string* Proc_Sprite::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.name)
  return name_;
}
inline ::std::string* Proc_Sprite::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Sprite::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.name)
}

// required string packetName = 4;
inline bool Proc_Sprite::has_packetname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proc_Sprite::set_has_packetname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proc_Sprite::clear_has_packetname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proc_Sprite::clear_packetname() {
  if (packetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetname_->clear();
  }
  clear_has_packetname();
}
inline const ::std::string& Proc_Sprite::packetname() const {
  // @@protoc_insertion_point(field_get:Proc_Sprite.packetName)
  return *packetname_;
}
inline void Proc_Sprite::set_packetname(const ::std::string& value) {
  set_has_packetname();
  if (packetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Sprite.packetName)
}
inline void Proc_Sprite::set_packetname(const char* value) {
  set_has_packetname();
  if (packetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Sprite.packetName)
}
inline void Proc_Sprite::set_packetname(const char* value, size_t size) {
  set_has_packetname();
  if (packetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Sprite.packetName)
}
inline ::std::string* Proc_Sprite::mutable_packetname() {
  set_has_packetname();
  if (packetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    packetname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Sprite.packetName)
  return packetname_;
}
inline ::std::string* Proc_Sprite::release_packetname() {
  clear_has_packetname();
  if (packetname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = packetname_;
    packetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Sprite::set_allocated_packetname(::std::string* packetname) {
  if (packetname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete packetname_;
  }
  if (packetname) {
    set_has_packetname();
    packetname_ = packetname;
  } else {
    clear_has_packetname();
    packetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Sprite.packetName)
}

// -------------------------------------------------------------------

// Proc_OwnSprite

// required .Proc_Sprite Proc_Sprite = 1;
inline bool Proc_OwnSprite::has_proc_sprite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_OwnSprite::set_has_proc_sprite() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_OwnSprite::clear_has_proc_sprite() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_OwnSprite::clear_proc_sprite() {
  if (proc_sprite_ != NULL) proc_sprite_->::Proc_Sprite::Clear();
  clear_has_proc_sprite();
}
inline const ::Proc_Sprite& Proc_OwnSprite::proc_sprite() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.Proc_Sprite)
  return proc_sprite_ != NULL ? *proc_sprite_ : *default_instance_->proc_sprite_;
}
inline ::Proc_Sprite* Proc_OwnSprite::mutable_proc_sprite() {
  set_has_proc_sprite();
  if (proc_sprite_ == NULL) proc_sprite_ = new ::Proc_Sprite;
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.Proc_Sprite)
  return proc_sprite_;
}
inline ::Proc_Sprite* Proc_OwnSprite::release_proc_sprite() {
  clear_has_proc_sprite();
  ::Proc_Sprite* temp = proc_sprite_;
  proc_sprite_ = NULL;
  return temp;
}
inline void Proc_OwnSprite::set_allocated_proc_sprite(::Proc_Sprite* proc_sprite) {
  delete proc_sprite_;
  proc_sprite_ = proc_sprite;
  if (proc_sprite) {
    set_has_proc_sprite();
  } else {
    clear_has_proc_sprite();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.Proc_Sprite)
}

// required .Proc_Vec2 offsetPos = 2;
inline bool Proc_OwnSprite::has_offsetpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_OwnSprite::set_has_offsetpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_OwnSprite::clear_has_offsetpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_OwnSprite::clear_offsetpos() {
  if (offsetpos_ != NULL) offsetpos_->::Proc_Vec2::Clear();
  clear_has_offsetpos();
}
inline const ::Proc_Vec2& Proc_OwnSprite::offsetpos() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.offsetPos)
  return offsetpos_ != NULL ? *offsetpos_ : *default_instance_->offsetpos_;
}
inline ::Proc_Vec2* Proc_OwnSprite::mutable_offsetpos() {
  set_has_offsetpos();
  if (offsetpos_ == NULL) offsetpos_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.offsetPos)
  return offsetpos_;
}
inline ::Proc_Vec2* Proc_OwnSprite::release_offsetpos() {
  clear_has_offsetpos();
  ::Proc_Vec2* temp = offsetpos_;
  offsetpos_ = NULL;
  return temp;
}
inline void Proc_OwnSprite::set_allocated_offsetpos(::Proc_Vec2* offsetpos) {
  delete offsetpos_;
  offsetpos_ = offsetpos;
  if (offsetpos) {
    set_has_offsetpos();
  } else {
    clear_has_offsetpos();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.offsetPos)
}

// required .Proc_Vec2 offsetScale = 3;
inline bool Proc_OwnSprite::has_offsetscale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_OwnSprite::set_has_offsetscale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_OwnSprite::clear_has_offsetscale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_OwnSprite::clear_offsetscale() {
  if (offsetscale_ != NULL) offsetscale_->::Proc_Vec2::Clear();
  clear_has_offsetscale();
}
inline const ::Proc_Vec2& Proc_OwnSprite::offsetscale() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.offsetScale)
  return offsetscale_ != NULL ? *offsetscale_ : *default_instance_->offsetscale_;
}
inline ::Proc_Vec2* Proc_OwnSprite::mutable_offsetscale() {
  set_has_offsetscale();
  if (offsetscale_ == NULL) offsetscale_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.offsetScale)
  return offsetscale_;
}
inline ::Proc_Vec2* Proc_OwnSprite::release_offsetscale() {
  clear_has_offsetscale();
  ::Proc_Vec2* temp = offsetscale_;
  offsetscale_ = NULL;
  return temp;
}
inline void Proc_OwnSprite::set_allocated_offsetscale(::Proc_Vec2* offsetscale) {
  delete offsetscale_;
  offsetscale_ = offsetscale;
  if (offsetscale) {
    set_has_offsetscale();
  } else {
    clear_has_offsetscale();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.offsetScale)
}

// required .Proc_Vec4 color = 4;
inline bool Proc_OwnSprite::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proc_OwnSprite::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proc_OwnSprite::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proc_OwnSprite::clear_color() {
  if (color_ != NULL) color_->::Proc_Vec4::Clear();
  clear_has_color();
}
inline const ::Proc_Vec4& Proc_OwnSprite::color() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Proc_Vec4* Proc_OwnSprite::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Proc_Vec4;
  // @@protoc_insertion_point(field_mutable:Proc_OwnSprite.color)
  return color_;
}
inline ::Proc_Vec4* Proc_OwnSprite::release_color() {
  clear_has_color();
  ::Proc_Vec4* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Proc_OwnSprite::set_allocated_color(::Proc_Vec4* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_OwnSprite.color)
}

// required float depth = 5;
inline bool Proc_OwnSprite::has_depth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proc_OwnSprite::set_has_depth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proc_OwnSprite::clear_has_depth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proc_OwnSprite::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline float Proc_OwnSprite::depth() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.depth)
  return depth_;
}
inline void Proc_OwnSprite::set_depth(float value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:Proc_OwnSprite.depth)
}

// optional float angle = 6;
inline bool Proc_OwnSprite::has_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Proc_OwnSprite::set_has_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Proc_OwnSprite::clear_has_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Proc_OwnSprite::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Proc_OwnSprite::angle() const {
  // @@protoc_insertion_point(field_get:Proc_OwnSprite.angle)
  return angle_;
}
inline void Proc_OwnSprite::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:Proc_OwnSprite.angle)
}

// -------------------------------------------------------------------

// Proc_Object

// required string name = 1;
inline bool Proc_Object::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Object::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Object::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Object::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Proc_Object::name() const {
  // @@protoc_insertion_point(field_get:Proc_Object.name)
  return *name_;
}
inline void Proc_Object::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Object.name)
}
inline void Proc_Object::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Object.name)
}
inline void Proc_Object::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Object.name)
}
inline ::std::string* Proc_Object::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Object.name)
  return name_;
}
inline ::std::string* Proc_Object::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Object::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Object.name)
}

// repeated .Proc_OwnSprite Proc_SpriteList = 2;
inline int Proc_Object::proc_spritelist_size() const {
  return proc_spritelist_.size();
}
inline void Proc_Object::clear_proc_spritelist() {
  proc_spritelist_.Clear();
}
inline const ::Proc_OwnSprite& Proc_Object::proc_spritelist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.Proc_SpriteList)
  return proc_spritelist_.Get(index);
}
inline ::Proc_OwnSprite* Proc_Object::mutable_proc_spritelist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.Proc_SpriteList)
  return proc_spritelist_.Mutable(index);
}
inline ::Proc_OwnSprite* Proc_Object::add_proc_spritelist() {
  // @@protoc_insertion_point(field_add:Proc_Object.Proc_SpriteList)
  return proc_spritelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_OwnSprite >&
Proc_Object::proc_spritelist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.Proc_SpriteList)
  return proc_spritelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_OwnSprite >*
Proc_Object::mutable_proc_spritelist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.Proc_SpriteList)
  return &proc_spritelist_;
}

// repeated .Proc_SpotLight lightList = 3;
inline int Proc_Object::lightlist_size() const {
  return lightlist_.size();
}
inline void Proc_Object::clear_lightlist() {
  lightlist_.Clear();
}
inline const ::Proc_SpotLight& Proc_Object::lightlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.lightList)
  return lightlist_.Get(index);
}
inline ::Proc_SpotLight* Proc_Object::mutable_lightlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.lightList)
  return lightlist_.Mutable(index);
}
inline ::Proc_SpotLight* Proc_Object::add_lightlist() {
  // @@protoc_insertion_point(field_add:Proc_Object.lightList)
  return lightlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_SpotLight >&
Proc_Object::lightlist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.lightList)
  return lightlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_SpotLight >*
Proc_Object::mutable_lightlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.lightList)
  return &lightlist_;
}

// repeated .Proc_ColiderBox coliderList = 4;
inline int Proc_Object::coliderlist_size() const {
  return coliderlist_.size();
}
inline void Proc_Object::clear_coliderlist() {
  coliderlist_.Clear();
}
inline const ::Proc_ColiderBox& Proc_Object::coliderlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Object.coliderList)
  return coliderlist_.Get(index);
}
inline ::Proc_ColiderBox* Proc_Object::mutable_coliderlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Object.coliderList)
  return coliderlist_.Mutable(index);
}
inline ::Proc_ColiderBox* Proc_Object::add_coliderlist() {
  // @@protoc_insertion_point(field_add:Proc_Object.coliderList)
  return coliderlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_ColiderBox >&
Proc_Object::coliderlist() const {
  // @@protoc_insertion_point(field_list:Proc_Object.coliderList)
  return coliderlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_ColiderBox >*
Proc_Object::mutable_coliderlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Object.coliderList)
  return &coliderlist_;
}

// -------------------------------------------------------------------

// Proc_LoadObject

// required .Proc_Object refab = 1;
inline bool Proc_LoadObject::has_refab() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_LoadObject::set_has_refab() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_LoadObject::clear_has_refab() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_LoadObject::clear_refab() {
  if (refab_ != NULL) refab_->::Proc_Object::Clear();
  clear_has_refab();
}
inline const ::Proc_Object& Proc_LoadObject::refab() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.refab)
  return refab_ != NULL ? *refab_ : *default_instance_->refab_;
}
inline ::Proc_Object* Proc_LoadObject::mutable_refab() {
  set_has_refab();
  if (refab_ == NULL) refab_ = new ::Proc_Object;
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.refab)
  return refab_;
}
inline ::Proc_Object* Proc_LoadObject::release_refab() {
  clear_has_refab();
  ::Proc_Object* temp = refab_;
  refab_ = NULL;
  return temp;
}
inline void Proc_LoadObject::set_allocated_refab(::Proc_Object* refab) {
  delete refab_;
  refab_ = refab;
  if (refab) {
    set_has_refab();
  } else {
    clear_has_refab();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.refab)
}

// required .Proc_Vec2 pos = 2;
inline bool Proc_LoadObject::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_LoadObject::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_LoadObject::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_LoadObject::clear_pos() {
  if (pos_ != NULL) pos_->::Proc_Vec2::Clear();
  clear_has_pos();
}
inline const ::Proc_Vec2& Proc_LoadObject::pos() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Proc_Vec2* Proc_LoadObject::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.pos)
  return pos_;
}
inline ::Proc_Vec2* Proc_LoadObject::release_pos() {
  clear_has_pos();
  ::Proc_Vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Proc_LoadObject::set_allocated_pos(::Proc_Vec2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.pos)
}

// required .Proc_Vec4 color = 3;
inline bool Proc_LoadObject::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_LoadObject::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_LoadObject::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_LoadObject::clear_color() {
  if (color_ != NULL) color_->::Proc_Vec4::Clear();
  clear_has_color();
}
inline const ::Proc_Vec4& Proc_LoadObject::color() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Proc_Vec4* Proc_LoadObject::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Proc_Vec4;
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.color)
  return color_;
}
inline ::Proc_Vec4* Proc_LoadObject::release_color() {
  clear_has_color();
  ::Proc_Vec4* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Proc_LoadObject::set_allocated_color(::Proc_Vec4* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.color)
}

// required float angle = 4;
inline bool Proc_LoadObject::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proc_LoadObject::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proc_LoadObject::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proc_LoadObject::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Proc_LoadObject::angle() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.angle)
  return angle_;
}
inline void Proc_LoadObject::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:Proc_LoadObject.angle)
}

// required .Proc_Vec2 scale = 5;
inline bool Proc_LoadObject::has_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proc_LoadObject::set_has_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proc_LoadObject::clear_has_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proc_LoadObject::clear_scale() {
  if (scale_ != NULL) scale_->::Proc_Vec2::Clear();
  clear_has_scale();
}
inline const ::Proc_Vec2& Proc_LoadObject::scale() const {
  // @@protoc_insertion_point(field_get:Proc_LoadObject.scale)
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Proc_Vec2* Proc_LoadObject::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_LoadObject.scale)
  return scale_;
}
inline ::Proc_Vec2* Proc_LoadObject::release_scale() {
  clear_has_scale();
  ::Proc_Vec2* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Proc_LoadObject::set_allocated_scale(::Proc_Vec2* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_LoadObject.scale)
}

// -------------------------------------------------------------------

// Proc_Brush

// required string textureName = 1;
inline bool Proc_Brush::has_texturename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Brush::set_has_texturename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Brush::clear_has_texturename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Brush::clear_texturename() {
  if (texturename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturename_->clear();
  }
  clear_has_texturename();
}
inline const ::std::string& Proc_Brush::texturename() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.textureName)
  return *texturename_;
}
inline void Proc_Brush::set_texturename(const ::std::string& value) {
  set_has_texturename();
  if (texturename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturename_ = new ::std::string;
  }
  texturename_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Brush.textureName)
}
inline void Proc_Brush::set_texturename(const char* value) {
  set_has_texturename();
  if (texturename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturename_ = new ::std::string;
  }
  texturename_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Brush.textureName)
}
inline void Proc_Brush::set_texturename(const char* value, size_t size) {
  set_has_texturename();
  if (texturename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturename_ = new ::std::string;
  }
  texturename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Brush.textureName)
}
inline ::std::string* Proc_Brush::mutable_texturename() {
  set_has_texturename();
  if (texturename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Brush.textureName)
  return texturename_;
}
inline ::std::string* Proc_Brush::release_texturename() {
  clear_has_texturename();
  if (texturename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = texturename_;
    texturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Brush::set_allocated_texturename(::std::string* texturename) {
  if (texturename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete texturename_;
  }
  if (texturename) {
    set_has_texturename();
    texturename_ = texturename;
  } else {
    clear_has_texturename();
    texturename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.textureName)
}

// required .Proc_Vec2 pos = 2;
inline bool Proc_Brush::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Brush::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Brush::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Brush::clear_pos() {
  if (pos_ != NULL) pos_->::Proc_Vec2::Clear();
  clear_has_pos();
}
inline const ::Proc_Vec2& Proc_Brush::pos() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_Brush.pos)
  return pos_;
}
inline ::Proc_Vec2* Proc_Brush::release_pos() {
  clear_has_pos();
  ::Proc_Vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Proc_Brush::set_allocated_pos(::Proc_Vec2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.pos)
}

// required .Proc_Vec2 dim = 3;
inline bool Proc_Brush::has_dim() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Proc_Brush::set_has_dim() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Proc_Brush::clear_has_dim() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Proc_Brush::clear_dim() {
  if (dim_ != NULL) dim_->::Proc_Vec2::Clear();
  clear_has_dim();
}
inline const ::Proc_Vec2& Proc_Brush::dim() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.dim)
  return dim_ != NULL ? *dim_ : *default_instance_->dim_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_dim() {
  set_has_dim();
  if (dim_ == NULL) dim_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_Brush.dim)
  return dim_;
}
inline ::Proc_Vec2* Proc_Brush::release_dim() {
  clear_has_dim();
  ::Proc_Vec2* temp = dim_;
  dim_ = NULL;
  return temp;
}
inline void Proc_Brush::set_allocated_dim(::Proc_Vec2* dim) {
  delete dim_;
  dim_ = dim;
  if (dim) {
    set_has_dim();
  } else {
    clear_has_dim();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.dim)
}

// required .Proc_Vec2 uv = 4;
inline bool Proc_Brush::has_uv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Proc_Brush::set_has_uv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Proc_Brush::clear_has_uv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Proc_Brush::clear_uv() {
  if (uv_ != NULL) uv_->::Proc_Vec2::Clear();
  clear_has_uv();
}
inline const ::Proc_Vec2& Proc_Brush::uv() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.uv)
  return uv_ != NULL ? *uv_ : *default_instance_->uv_;
}
inline ::Proc_Vec2* Proc_Brush::mutable_uv() {
  set_has_uv();
  if (uv_ == NULL) uv_ = new ::Proc_Vec2;
  // @@protoc_insertion_point(field_mutable:Proc_Brush.uv)
  return uv_;
}
inline ::Proc_Vec2* Proc_Brush::release_uv() {
  clear_has_uv();
  ::Proc_Vec2* temp = uv_;
  uv_ = NULL;
  return temp;
}
inline void Proc_Brush::set_allocated_uv(::Proc_Vec2* uv) {
  delete uv_;
  uv_ = uv;
  if (uv) {
    set_has_uv();
  } else {
    clear_has_uv();
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Brush.uv)
}

// required float depth = 5;
inline bool Proc_Brush::has_depth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Proc_Brush::set_has_depth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Proc_Brush::clear_has_depth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Proc_Brush::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline float Proc_Brush::depth() const {
  // @@protoc_insertion_point(field_get:Proc_Brush.depth)
  return depth_;
}
inline void Proc_Brush::set_depth(float value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:Proc_Brush.depth)
}

// -------------------------------------------------------------------

// Proc_Layer

// required string name = 1;
inline bool Proc_Layer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Layer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Layer::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Proc_Layer::name() const {
  // @@protoc_insertion_point(field_get:Proc_Layer.name)
  return *name_;
}
inline void Proc_Layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Layer.name)
}
inline void Proc_Layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Layer.name)
}
inline void Proc_Layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Layer.name)
}
inline ::std::string* Proc_Layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Layer.name)
  return name_;
}
inline ::std::string* Proc_Layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Layer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Layer.name)
}

// required int32 depth = 2;
inline bool Proc_Layer::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Proc_Layer::set_has_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Proc_Layer::clear_has_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Proc_Layer::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline ::google::protobuf::int32 Proc_Layer::depth() const {
  // @@protoc_insertion_point(field_get:Proc_Layer.depth)
  return depth_;
}
inline void Proc_Layer::set_depth(::google::protobuf::int32 value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:Proc_Layer.depth)
}

// repeated .Proc_LoadObject objectList = 3;
inline int Proc_Layer::objectlist_size() const {
  return objectlist_.size();
}
inline void Proc_Layer::clear_objectlist() {
  objectlist_.Clear();
}
inline const ::Proc_LoadObject& Proc_Layer::objectlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Layer.objectList)
  return objectlist_.Get(index);
}
inline ::Proc_LoadObject* Proc_Layer::mutable_objectlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Layer.objectList)
  return objectlist_.Mutable(index);
}
inline ::Proc_LoadObject* Proc_Layer::add_objectlist() {
  // @@protoc_insertion_point(field_add:Proc_Layer.objectList)
  return objectlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_LoadObject >&
Proc_Layer::objectlist() const {
  // @@protoc_insertion_point(field_list:Proc_Layer.objectList)
  return objectlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_LoadObject >*
Proc_Layer::mutable_objectlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Layer.objectList)
  return &objectlist_;
}

// repeated .Proc_Brush brushList = 4;
inline int Proc_Layer::brushlist_size() const {
  return brushlist_.size();
}
inline void Proc_Layer::clear_brushlist() {
  brushlist_.Clear();
}
inline const ::Proc_Brush& Proc_Layer::brushlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Layer.brushList)
  return brushlist_.Get(index);
}
inline ::Proc_Brush* Proc_Layer::mutable_brushlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Layer.brushList)
  return brushlist_.Mutable(index);
}
inline ::Proc_Brush* Proc_Layer::add_brushlist() {
  // @@protoc_insertion_point(field_add:Proc_Layer.brushList)
  return brushlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_Brush >&
Proc_Layer::brushlist() const {
  // @@protoc_insertion_point(field_list:Proc_Layer.brushList)
  return brushlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_Brush >*
Proc_Layer::mutable_brushlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Layer.brushList)
  return &brushlist_;
}

// -------------------------------------------------------------------

// Proc_Scene

// required string name = 1;
inline bool Proc_Scene::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proc_Scene::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proc_Scene::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proc_Scene::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Proc_Scene::name() const {
  // @@protoc_insertion_point(field_get:Proc_Scene.name)
  return *name_;
}
inline void Proc_Scene::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Proc_Scene.name)
}
inline void Proc_Scene::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proc_Scene.name)
}
inline void Proc_Scene::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proc_Scene.name)
}
inline ::std::string* Proc_Scene::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proc_Scene.name)
  return name_;
}
inline ::std::string* Proc_Scene::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proc_Scene::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proc_Scene.name)
}

// repeated .Proc_Layer layerList = 2;
inline int Proc_Scene::layerlist_size() const {
  return layerlist_.size();
}
inline void Proc_Scene::clear_layerlist() {
  layerlist_.Clear();
}
inline const ::Proc_Layer& Proc_Scene::layerlist(int index) const {
  // @@protoc_insertion_point(field_get:Proc_Scene.layerList)
  return layerlist_.Get(index);
}
inline ::Proc_Layer* Proc_Scene::mutable_layerlist(int index) {
  // @@protoc_insertion_point(field_mutable:Proc_Scene.layerList)
  return layerlist_.Mutable(index);
}
inline ::Proc_Layer* Proc_Scene::add_layerlist() {
  // @@protoc_insertion_point(field_add:Proc_Scene.layerList)
  return layerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Proc_Layer >&
Proc_Scene::layerlist() const {
  // @@protoc_insertion_point(field_list:Proc_Scene.layerList)
  return layerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Proc_Layer >*
Proc_Scene::mutable_layerlist() {
  // @@protoc_insertion_point(field_mutable_list:Proc_Scene.layerList)
  return &layerlist_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_objectData_2eproto__INCLUDED
