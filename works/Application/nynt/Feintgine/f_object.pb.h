// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: f_object.proto

#ifndef PROTOBUF_f_5fobject_2eproto__INCLUDED
#define PROTOBUF_f_5fobject_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_f_5fobject_2eproto();
void protobuf_AssignDesc_f_5fobject_2eproto();
void protobuf_ShutdownFile_f_5fobject_2eproto();

class f_vec2;
class f_object_color;
class f_object_uv;
class f_colider;
class f_object;
class Sprite;
class Layer;
class Scence;

// ===================================================================

class f_vec2 : public ::google::protobuf::Message {
 public:
  f_vec2();
  virtual ~f_vec2();

  f_vec2(const f_vec2& from);

  inline f_vec2& operator=(const f_vec2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const f_vec2& default_instance();

  void Swap(f_vec2* other);

  // implements Message ----------------------------------------------

  f_vec2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const f_vec2& from);
  void MergeFrom(const f_vec2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:f_vec2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static f_vec2* default_instance_;
};
// -------------------------------------------------------------------

class f_object_color : public ::google::protobuf::Message {
 public:
  f_object_color();
  virtual ~f_object_color();

  f_object_color(const f_object_color& from);

  inline f_object_color& operator=(const f_object_color& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const f_object_color& default_instance();

  void Swap(f_object_color* other);

  // implements Message ----------------------------------------------

  f_object_color* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const f_object_color& from);
  void MergeFrom(const f_object_color& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float color_r = 1;
  inline bool has_color_r() const;
  inline void clear_color_r();
  static const int kColorRFieldNumber = 1;
  inline float color_r() const;
  inline void set_color_r(float value);

  // required float color_g = 2;
  inline bool has_color_g() const;
  inline void clear_color_g();
  static const int kColorGFieldNumber = 2;
  inline float color_g() const;
  inline void set_color_g(float value);

  // required float color_b = 3;
  inline bool has_color_b() const;
  inline void clear_color_b();
  static const int kColorBFieldNumber = 3;
  inline float color_b() const;
  inline void set_color_b(float value);

  // required float color_a = 4;
  inline bool has_color_a() const;
  inline void clear_color_a();
  static const int kColorAFieldNumber = 4;
  inline float color_a() const;
  inline void set_color_a(float value);

  // @@protoc_insertion_point(class_scope:f_object_color)
 private:
  inline void set_has_color_r();
  inline void clear_has_color_r();
  inline void set_has_color_g();
  inline void clear_has_color_g();
  inline void set_has_color_b();
  inline void clear_has_color_b();
  inline void set_has_color_a();
  inline void clear_has_color_a();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float color_r_;
  float color_g_;
  float color_b_;
  float color_a_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static f_object_color* default_instance_;
};
// -------------------------------------------------------------------

class f_object_uv : public ::google::protobuf::Message {
 public:
  f_object_uv();
  virtual ~f_object_uv();

  f_object_uv(const f_object_uv& from);

  inline f_object_uv& operator=(const f_object_uv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const f_object_uv& default_instance();

  void Swap(f_object_uv* other);

  // implements Message ----------------------------------------------

  f_object_uv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const f_object_uv& from);
  void MergeFrom(const f_object_uv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .f_vec2 xy = 1;
  inline bool has_xy() const;
  inline void clear_xy();
  static const int kXyFieldNumber = 1;
  inline const ::f_vec2& xy() const;
  inline ::f_vec2* mutable_xy();
  inline ::f_vec2* release_xy();
  inline void set_allocated_xy(::f_vec2* xy);

  // required .f_vec2 zw = 2;
  inline bool has_zw() const;
  inline void clear_zw();
  static const int kZwFieldNumber = 2;
  inline const ::f_vec2& zw() const;
  inline ::f_vec2* mutable_zw();
  inline ::f_vec2* release_zw();
  inline void set_allocated_zw(::f_vec2* zw);

  // @@protoc_insertion_point(class_scope:f_object_uv)
 private:
  inline void set_has_xy();
  inline void clear_has_xy();
  inline void set_has_zw();
  inline void clear_has_zw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::f_vec2* xy_;
  ::f_vec2* zw_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static f_object_uv* default_instance_;
};
// -------------------------------------------------------------------

class f_colider : public ::google::protobuf::Message {
 public:
  f_colider();
  virtual ~f_colider();

  f_colider(const f_colider& from);

  inline f_colider& operator=(const f_colider& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const f_colider& default_instance();

  void Swap(f_colider* other);

  // implements Message ----------------------------------------------

  f_colider* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const f_colider& from);
  void MergeFrom(const f_colider& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .f_vec2 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::f_vec2& pos() const;
  inline ::f_vec2* mutable_pos();
  inline ::f_vec2* release_pos();
  inline void set_allocated_pos(::f_vec2* pos);

  // required .f_vec2 dim = 2;
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline const ::f_vec2& dim() const;
  inline ::f_vec2* mutable_dim();
  inline ::f_vec2* release_dim();
  inline void set_allocated_dim(::f_vec2* dim);

  // @@protoc_insertion_point(class_scope:f_colider)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_dim();
  inline void clear_has_dim();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::f_vec2* pos_;
  ::f_vec2* dim_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static f_colider* default_instance_;
};
// -------------------------------------------------------------------

class f_object : public ::google::protobuf::Message {
 public:
  f_object();
  virtual ~f_object();

  f_object(const f_object& from);

  inline f_object& operator=(const f_object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const f_object& default_instance();

  void Swap(f_object* other);

  // implements Message ----------------------------------------------

  f_object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const f_object& from);
  void MergeFrom(const f_object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required .f_object_uv uv = 3;
  inline bool has_uv() const;
  inline void clear_uv();
  static const int kUvFieldNumber = 3;
  inline const ::f_object_uv& uv() const;
  inline ::f_object_uv* mutable_uv();
  inline ::f_object_uv* release_uv();
  inline void set_allocated_uv(::f_object_uv* uv);

  // required float width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline float width() const;
  inline void set_width(float value);

  // required float heigh = 5;
  inline bool has_heigh() const;
  inline void clear_heigh();
  static const int kHeighFieldNumber = 5;
  inline float heigh() const;
  inline void set_heigh(float value);

  // required .f_object_color color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::f_object_color& color() const;
  inline ::f_object_color* mutable_color();
  inline ::f_object_color* release_color();
  inline void set_allocated_color(::f_object_color* color);

  // repeated .f_colider coliderList = 7;
  inline int coliderlist_size() const;
  inline void clear_coliderlist();
  static const int kColiderListFieldNumber = 7;
  inline const ::f_colider& coliderlist(int index) const;
  inline ::f_colider* mutable_coliderlist(int index);
  inline ::f_colider* add_coliderlist();
  inline const ::google::protobuf::RepeatedPtrField< ::f_colider >&
      coliderlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::f_colider >*
      mutable_coliderlist();

  // required string texturePath = 8;
  inline bool has_texturepath() const;
  inline void clear_texturepath();
  static const int kTexturePathFieldNumber = 8;
  inline const ::std::string& texturepath() const;
  inline void set_texturepath(const ::std::string& value);
  inline void set_texturepath(const char* value);
  inline void set_texturepath(const char* value, size_t size);
  inline ::std::string* mutable_texturepath();
  inline ::std::string* release_texturepath();
  inline void set_allocated_texturepath(::std::string* texturepath);

  // @@protoc_insertion_point(class_scope:f_object)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uv();
  inline void clear_has_uv();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_heigh();
  inline void clear_has_heigh();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_texturepath();
  inline void clear_has_texturepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::f_object_uv* uv_;
  ::google::protobuf::int32 type_;
  float width_;
  ::f_object_color* color_;
  ::google::protobuf::RepeatedPtrField< ::f_colider > coliderlist_;
  ::std::string* texturepath_;
  float heigh_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static f_object* default_instance_;
};
// -------------------------------------------------------------------

class Sprite : public ::google::protobuf::Message {
 public:
  Sprite();
  virtual ~Sprite();

  Sprite(const Sprite& from);

  inline Sprite& operator=(const Sprite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sprite& default_instance();

  void Swap(Sprite* other);

  // implements Message ----------------------------------------------

  Sprite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sprite& from);
  void MergeFrom(const Sprite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x_pos = 1;
  inline bool has_x_pos() const;
  inline void clear_x_pos();
  static const int kXPosFieldNumber = 1;
  inline float x_pos() const;
  inline void set_x_pos(float value);

  // required float y_pos = 2;
  inline bool has_y_pos() const;
  inline void clear_y_pos();
  static const int kYPosFieldNumber = 2;
  inline float y_pos() const;
  inline void set_y_pos(float value);

  // required float x_scale = 3;
  inline bool has_x_scale() const;
  inline void clear_x_scale();
  static const int kXScaleFieldNumber = 3;
  inline float x_scale() const;
  inline void set_x_scale(float value);

  // required float y_scale = 4;
  inline bool has_y_scale() const;
  inline void clear_y_scale();
  static const int kYScaleFieldNumber = 4;
  inline float y_scale() const;
  inline void set_y_scale(float value);

  // required float angle = 5;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 5;
  inline float angle() const;
  inline void set_angle(float value);

  // required string prefab = 6;
  inline bool has_prefab() const;
  inline void clear_prefab();
  static const int kPrefabFieldNumber = 6;
  inline const ::std::string& prefab() const;
  inline void set_prefab(const ::std::string& value);
  inline void set_prefab(const char* value);
  inline void set_prefab(const char* value, size_t size);
  inline ::std::string* mutable_prefab();
  inline ::std::string* release_prefab();
  inline void set_allocated_prefab(::std::string* prefab);

  // @@protoc_insertion_point(class_scope:Sprite)
 private:
  inline void set_has_x_pos();
  inline void clear_has_x_pos();
  inline void set_has_y_pos();
  inline void clear_has_y_pos();
  inline void set_has_x_scale();
  inline void clear_has_x_scale();
  inline void set_has_y_scale();
  inline void clear_has_y_scale();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_prefab();
  inline void clear_has_prefab();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_pos_;
  float y_pos_;
  float x_scale_;
  float y_scale_;
  ::std::string* prefab_;
  float angle_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static Sprite* default_instance_;
};
// -------------------------------------------------------------------

class Layer : public ::google::protobuf::Message {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layer& default_instance();

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 depth = 2;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 2;
  inline ::google::protobuf::int32 depth() const;
  inline void set_depth(::google::protobuf::int32 value);

  // repeated .Sprite objects = 3;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 3;
  inline const ::Sprite& objects(int index) const;
  inline ::Sprite* mutable_objects(int index);
  inline ::Sprite* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::Sprite >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::Sprite >*
      mutable_objects();

  // @@protoc_insertion_point(class_scope:Layer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_depth();
  inline void clear_has_depth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Sprite > objects_;
  ::google::protobuf::int32 depth_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class Scence : public ::google::protobuf::Message {
 public:
  Scence();
  virtual ~Scence();

  Scence(const Scence& from);

  inline Scence& operator=(const Scence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scence& default_instance();

  void Swap(Scence* other);

  // implements Message ----------------------------------------------

  Scence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scence& from);
  void MergeFrom(const Scence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Layer layers = 2;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 2;
  inline const ::Layer& layers(int index) const;
  inline ::Layer* mutable_layers(int index);
  inline ::Layer* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::Layer >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::Layer >*
      mutable_layers();

  // @@protoc_insertion_point(class_scope:Scence)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Layer > layers_;
  friend void  protobuf_AddDesc_f_5fobject_2eproto();
  friend void protobuf_AssignDesc_f_5fobject_2eproto();
  friend void protobuf_ShutdownFile_f_5fobject_2eproto();

  void InitAsDefaultInstance();
  static Scence* default_instance_;
};
// ===================================================================


// ===================================================================

// f_vec2

// required float x = 1;
inline bool f_vec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void f_vec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void f_vec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void f_vec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float f_vec2::x() const {
  // @@protoc_insertion_point(field_get:f_vec2.x)
  return x_;
}
inline void f_vec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:f_vec2.x)
}

// required float y = 2;
inline bool f_vec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void f_vec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void f_vec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void f_vec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float f_vec2::y() const {
  // @@protoc_insertion_point(field_get:f_vec2.y)
  return y_;
}
inline void f_vec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:f_vec2.y)
}

// -------------------------------------------------------------------

// f_object_color

// required float color_r = 1;
inline bool f_object_color::has_color_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void f_object_color::set_has_color_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void f_object_color::clear_has_color_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void f_object_color::clear_color_r() {
  color_r_ = 0;
  clear_has_color_r();
}
inline float f_object_color::color_r() const {
  // @@protoc_insertion_point(field_get:f_object_color.color_r)
  return color_r_;
}
inline void f_object_color::set_color_r(float value) {
  set_has_color_r();
  color_r_ = value;
  // @@protoc_insertion_point(field_set:f_object_color.color_r)
}

// required float color_g = 2;
inline bool f_object_color::has_color_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void f_object_color::set_has_color_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void f_object_color::clear_has_color_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void f_object_color::clear_color_g() {
  color_g_ = 0;
  clear_has_color_g();
}
inline float f_object_color::color_g() const {
  // @@protoc_insertion_point(field_get:f_object_color.color_g)
  return color_g_;
}
inline void f_object_color::set_color_g(float value) {
  set_has_color_g();
  color_g_ = value;
  // @@protoc_insertion_point(field_set:f_object_color.color_g)
}

// required float color_b = 3;
inline bool f_object_color::has_color_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void f_object_color::set_has_color_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void f_object_color::clear_has_color_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void f_object_color::clear_color_b() {
  color_b_ = 0;
  clear_has_color_b();
}
inline float f_object_color::color_b() const {
  // @@protoc_insertion_point(field_get:f_object_color.color_b)
  return color_b_;
}
inline void f_object_color::set_color_b(float value) {
  set_has_color_b();
  color_b_ = value;
  // @@protoc_insertion_point(field_set:f_object_color.color_b)
}

// required float color_a = 4;
inline bool f_object_color::has_color_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void f_object_color::set_has_color_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void f_object_color::clear_has_color_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void f_object_color::clear_color_a() {
  color_a_ = 0;
  clear_has_color_a();
}
inline float f_object_color::color_a() const {
  // @@protoc_insertion_point(field_get:f_object_color.color_a)
  return color_a_;
}
inline void f_object_color::set_color_a(float value) {
  set_has_color_a();
  color_a_ = value;
  // @@protoc_insertion_point(field_set:f_object_color.color_a)
}

// -------------------------------------------------------------------

// f_object_uv

// required .f_vec2 xy = 1;
inline bool f_object_uv::has_xy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void f_object_uv::set_has_xy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void f_object_uv::clear_has_xy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void f_object_uv::clear_xy() {
  if (xy_ != NULL) xy_->::f_vec2::Clear();
  clear_has_xy();
}
inline const ::f_vec2& f_object_uv::xy() const {
  // @@protoc_insertion_point(field_get:f_object_uv.xy)
  return xy_ != NULL ? *xy_ : *default_instance_->xy_;
}
inline ::f_vec2* f_object_uv::mutable_xy() {
  set_has_xy();
  if (xy_ == NULL) xy_ = new ::f_vec2;
  // @@protoc_insertion_point(field_mutable:f_object_uv.xy)
  return xy_;
}
inline ::f_vec2* f_object_uv::release_xy() {
  clear_has_xy();
  ::f_vec2* temp = xy_;
  xy_ = NULL;
  return temp;
}
inline void f_object_uv::set_allocated_xy(::f_vec2* xy) {
  delete xy_;
  xy_ = xy;
  if (xy) {
    set_has_xy();
  } else {
    clear_has_xy();
  }
  // @@protoc_insertion_point(field_set_allocated:f_object_uv.xy)
}

// required .f_vec2 zw = 2;
inline bool f_object_uv::has_zw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void f_object_uv::set_has_zw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void f_object_uv::clear_has_zw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void f_object_uv::clear_zw() {
  if (zw_ != NULL) zw_->::f_vec2::Clear();
  clear_has_zw();
}
inline const ::f_vec2& f_object_uv::zw() const {
  // @@protoc_insertion_point(field_get:f_object_uv.zw)
  return zw_ != NULL ? *zw_ : *default_instance_->zw_;
}
inline ::f_vec2* f_object_uv::mutable_zw() {
  set_has_zw();
  if (zw_ == NULL) zw_ = new ::f_vec2;
  // @@protoc_insertion_point(field_mutable:f_object_uv.zw)
  return zw_;
}
inline ::f_vec2* f_object_uv::release_zw() {
  clear_has_zw();
  ::f_vec2* temp = zw_;
  zw_ = NULL;
  return temp;
}
inline void f_object_uv::set_allocated_zw(::f_vec2* zw) {
  delete zw_;
  zw_ = zw;
  if (zw) {
    set_has_zw();
  } else {
    clear_has_zw();
  }
  // @@protoc_insertion_point(field_set_allocated:f_object_uv.zw)
}

// -------------------------------------------------------------------

// f_colider

// required .f_vec2 pos = 1;
inline bool f_colider::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void f_colider::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void f_colider::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void f_colider::clear_pos() {
  if (pos_ != NULL) pos_->::f_vec2::Clear();
  clear_has_pos();
}
inline const ::f_vec2& f_colider::pos() const {
  // @@protoc_insertion_point(field_get:f_colider.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::f_vec2* f_colider::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::f_vec2;
  // @@protoc_insertion_point(field_mutable:f_colider.pos)
  return pos_;
}
inline ::f_vec2* f_colider::release_pos() {
  clear_has_pos();
  ::f_vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void f_colider::set_allocated_pos(::f_vec2* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:f_colider.pos)
}

// required .f_vec2 dim = 2;
inline bool f_colider::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void f_colider::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void f_colider::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void f_colider::clear_dim() {
  if (dim_ != NULL) dim_->::f_vec2::Clear();
  clear_has_dim();
}
inline const ::f_vec2& f_colider::dim() const {
  // @@protoc_insertion_point(field_get:f_colider.dim)
  return dim_ != NULL ? *dim_ : *default_instance_->dim_;
}
inline ::f_vec2* f_colider::mutable_dim() {
  set_has_dim();
  if (dim_ == NULL) dim_ = new ::f_vec2;
  // @@protoc_insertion_point(field_mutable:f_colider.dim)
  return dim_;
}
inline ::f_vec2* f_colider::release_dim() {
  clear_has_dim();
  ::f_vec2* temp = dim_;
  dim_ = NULL;
  return temp;
}
inline void f_colider::set_allocated_dim(::f_vec2* dim) {
  delete dim_;
  dim_ = dim;
  if (dim) {
    set_has_dim();
  } else {
    clear_has_dim();
  }
  // @@protoc_insertion_point(field_set_allocated:f_colider.dim)
}

// -------------------------------------------------------------------

// f_object

// required string name = 1;
inline bool f_object::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void f_object::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void f_object::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void f_object::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& f_object::name() const {
  // @@protoc_insertion_point(field_get:f_object.name)
  return *name_;
}
inline void f_object::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:f_object.name)
}
inline void f_object::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:f_object.name)
}
inline void f_object::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:f_object.name)
}
inline ::std::string* f_object::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:f_object.name)
  return name_;
}
inline ::std::string* f_object::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void f_object::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:f_object.name)
}

// required int32 type = 2;
inline bool f_object::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void f_object::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void f_object::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void f_object::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 f_object::type() const {
  // @@protoc_insertion_point(field_get:f_object.type)
  return type_;
}
inline void f_object::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:f_object.type)
}

// required .f_object_uv uv = 3;
inline bool f_object::has_uv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void f_object::set_has_uv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void f_object::clear_has_uv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void f_object::clear_uv() {
  if (uv_ != NULL) uv_->::f_object_uv::Clear();
  clear_has_uv();
}
inline const ::f_object_uv& f_object::uv() const {
  // @@protoc_insertion_point(field_get:f_object.uv)
  return uv_ != NULL ? *uv_ : *default_instance_->uv_;
}
inline ::f_object_uv* f_object::mutable_uv() {
  set_has_uv();
  if (uv_ == NULL) uv_ = new ::f_object_uv;
  // @@protoc_insertion_point(field_mutable:f_object.uv)
  return uv_;
}
inline ::f_object_uv* f_object::release_uv() {
  clear_has_uv();
  ::f_object_uv* temp = uv_;
  uv_ = NULL;
  return temp;
}
inline void f_object::set_allocated_uv(::f_object_uv* uv) {
  delete uv_;
  uv_ = uv;
  if (uv) {
    set_has_uv();
  } else {
    clear_has_uv();
  }
  // @@protoc_insertion_point(field_set_allocated:f_object.uv)
}

// required float width = 4;
inline bool f_object::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void f_object::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void f_object::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void f_object::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float f_object::width() const {
  // @@protoc_insertion_point(field_get:f_object.width)
  return width_;
}
inline void f_object::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:f_object.width)
}

// required float heigh = 5;
inline bool f_object::has_heigh() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void f_object::set_has_heigh() {
  _has_bits_[0] |= 0x00000010u;
}
inline void f_object::clear_has_heigh() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void f_object::clear_heigh() {
  heigh_ = 0;
  clear_has_heigh();
}
inline float f_object::heigh() const {
  // @@protoc_insertion_point(field_get:f_object.heigh)
  return heigh_;
}
inline void f_object::set_heigh(float value) {
  set_has_heigh();
  heigh_ = value;
  // @@protoc_insertion_point(field_set:f_object.heigh)
}

// required .f_object_color color = 6;
inline bool f_object::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void f_object::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void f_object::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void f_object::clear_color() {
  if (color_ != NULL) color_->::f_object_color::Clear();
  clear_has_color();
}
inline const ::f_object_color& f_object::color() const {
  // @@protoc_insertion_point(field_get:f_object.color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::f_object_color* f_object::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::f_object_color;
  // @@protoc_insertion_point(field_mutable:f_object.color)
  return color_;
}
inline ::f_object_color* f_object::release_color() {
  clear_has_color();
  ::f_object_color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void f_object::set_allocated_color(::f_object_color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
  // @@protoc_insertion_point(field_set_allocated:f_object.color)
}

// repeated .f_colider coliderList = 7;
inline int f_object::coliderlist_size() const {
  return coliderlist_.size();
}
inline void f_object::clear_coliderlist() {
  coliderlist_.Clear();
}
inline const ::f_colider& f_object::coliderlist(int index) const {
  // @@protoc_insertion_point(field_get:f_object.coliderList)
  return coliderlist_.Get(index);
}
inline ::f_colider* f_object::mutable_coliderlist(int index) {
  // @@protoc_insertion_point(field_mutable:f_object.coliderList)
  return coliderlist_.Mutable(index);
}
inline ::f_colider* f_object::add_coliderlist() {
  // @@protoc_insertion_point(field_add:f_object.coliderList)
  return coliderlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::f_colider >&
f_object::coliderlist() const {
  // @@protoc_insertion_point(field_list:f_object.coliderList)
  return coliderlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::f_colider >*
f_object::mutable_coliderlist() {
  // @@protoc_insertion_point(field_mutable_list:f_object.coliderList)
  return &coliderlist_;
}

// required string texturePath = 8;
inline bool f_object::has_texturepath() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void f_object::set_has_texturepath() {
  _has_bits_[0] |= 0x00000080u;
}
inline void f_object::clear_has_texturepath() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void f_object::clear_texturepath() {
  if (texturepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_->clear();
  }
  clear_has_texturepath();
}
inline const ::std::string& f_object::texturepath() const {
  // @@protoc_insertion_point(field_get:f_object.texturePath)
  return *texturepath_;
}
inline void f_object::set_texturepath(const ::std::string& value) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(value);
  // @@protoc_insertion_point(field_set:f_object.texturePath)
}
inline void f_object::set_texturepath(const char* value) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:f_object.texturePath)
}
inline void f_object::set_texturepath(const char* value, size_t size) {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  texturepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:f_object.texturePath)
}
inline ::std::string* f_object::mutable_texturepath() {
  set_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    texturepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:f_object.texturePath)
  return texturepath_;
}
inline ::std::string* f_object::release_texturepath() {
  clear_has_texturepath();
  if (texturepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = texturepath_;
    texturepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void f_object::set_allocated_texturepath(::std::string* texturepath) {
  if (texturepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete texturepath_;
  }
  if (texturepath) {
    set_has_texturepath();
    texturepath_ = texturepath;
  } else {
    clear_has_texturepath();
    texturepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:f_object.texturePath)
}

// -------------------------------------------------------------------

// Sprite

// required float x_pos = 1;
inline bool Sprite::has_x_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sprite::set_has_x_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sprite::clear_has_x_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sprite::clear_x_pos() {
  x_pos_ = 0;
  clear_has_x_pos();
}
inline float Sprite::x_pos() const {
  // @@protoc_insertion_point(field_get:Sprite.x_pos)
  return x_pos_;
}
inline void Sprite::set_x_pos(float value) {
  set_has_x_pos();
  x_pos_ = value;
  // @@protoc_insertion_point(field_set:Sprite.x_pos)
}

// required float y_pos = 2;
inline bool Sprite::has_y_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sprite::set_has_y_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sprite::clear_has_y_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sprite::clear_y_pos() {
  y_pos_ = 0;
  clear_has_y_pos();
}
inline float Sprite::y_pos() const {
  // @@protoc_insertion_point(field_get:Sprite.y_pos)
  return y_pos_;
}
inline void Sprite::set_y_pos(float value) {
  set_has_y_pos();
  y_pos_ = value;
  // @@protoc_insertion_point(field_set:Sprite.y_pos)
}

// required float x_scale = 3;
inline bool Sprite::has_x_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sprite::set_has_x_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sprite::clear_has_x_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sprite::clear_x_scale() {
  x_scale_ = 0;
  clear_has_x_scale();
}
inline float Sprite::x_scale() const {
  // @@protoc_insertion_point(field_get:Sprite.x_scale)
  return x_scale_;
}
inline void Sprite::set_x_scale(float value) {
  set_has_x_scale();
  x_scale_ = value;
  // @@protoc_insertion_point(field_set:Sprite.x_scale)
}

// required float y_scale = 4;
inline bool Sprite::has_y_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sprite::set_has_y_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sprite::clear_has_y_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sprite::clear_y_scale() {
  y_scale_ = 0;
  clear_has_y_scale();
}
inline float Sprite::y_scale() const {
  // @@protoc_insertion_point(field_get:Sprite.y_scale)
  return y_scale_;
}
inline void Sprite::set_y_scale(float value) {
  set_has_y_scale();
  y_scale_ = value;
  // @@protoc_insertion_point(field_set:Sprite.y_scale)
}

// required float angle = 5;
inline bool Sprite::has_angle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sprite::set_has_angle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sprite::clear_has_angle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sprite::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Sprite::angle() const {
  // @@protoc_insertion_point(field_get:Sprite.angle)
  return angle_;
}
inline void Sprite::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:Sprite.angle)
}

// required string prefab = 6;
inline bool Sprite::has_prefab() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sprite::set_has_prefab() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sprite::clear_has_prefab() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sprite::clear_prefab() {
  if (prefab_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefab_->clear();
  }
  clear_has_prefab();
}
inline const ::std::string& Sprite::prefab() const {
  // @@protoc_insertion_point(field_get:Sprite.prefab)
  return *prefab_;
}
inline void Sprite::set_prefab(const ::std::string& value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
  // @@protoc_insertion_point(field_set:Sprite.prefab)
}
inline void Sprite::set_prefab(const char* value) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(value);
  // @@protoc_insertion_point(field_set_char:Sprite.prefab)
}
inline void Sprite::set_prefab(const char* value, size_t size) {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefab_ = new ::std::string;
  }
  prefab_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Sprite.prefab)
}
inline ::std::string* Sprite::mutable_prefab() {
  set_has_prefab();
  if (prefab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefab_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Sprite.prefab)
  return prefab_;
}
inline ::std::string* Sprite::release_prefab() {
  clear_has_prefab();
  if (prefab_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prefab_;
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Sprite::set_allocated_prefab(::std::string* prefab) {
  if (prefab_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prefab_;
  }
  if (prefab) {
    set_has_prefab();
    prefab_ = prefab;
  } else {
    clear_has_prefab();
    prefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Sprite.prefab)
}

// -------------------------------------------------------------------

// Layer

// required string name = 1;
inline bool Layer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Layer::name() const {
  // @@protoc_insertion_point(field_get:Layer.name)
  return *name_;
}
inline void Layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Layer.name)
}
inline void Layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Layer.name)
}
inline void Layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Layer.name)
}
inline ::std::string* Layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Layer.name)
  return name_;
}
inline ::std::string* Layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Layer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Layer.name)
}

// required int32 depth = 2;
inline bool Layer::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline ::google::protobuf::int32 Layer::depth() const {
  // @@protoc_insertion_point(field_get:Layer.depth)
  return depth_;
}
inline void Layer::set_depth(::google::protobuf::int32 value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:Layer.depth)
}

// repeated .Sprite objects = 3;
inline int Layer::objects_size() const {
  return objects_.size();
}
inline void Layer::clear_objects() {
  objects_.Clear();
}
inline const ::Sprite& Layer::objects(int index) const {
  // @@protoc_insertion_point(field_get:Layer.objects)
  return objects_.Get(index);
}
inline ::Sprite* Layer::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:Layer.objects)
  return objects_.Mutable(index);
}
inline ::Sprite* Layer::add_objects() {
  // @@protoc_insertion_point(field_add:Layer.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Sprite >&
Layer::objects() const {
  // @@protoc_insertion_point(field_list:Layer.objects)
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::Sprite >*
Layer::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:Layer.objects)
  return &objects_;
}

// -------------------------------------------------------------------

// Scence

// required string name = 1;
inline bool Scence::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scence::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scence::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scence::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Scence::name() const {
  // @@protoc_insertion_point(field_get:Scence.name)
  return *name_;
}
inline void Scence::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Scence.name)
}
inline void Scence::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Scence.name)
}
inline void Scence::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Scence.name)
}
inline ::std::string* Scence::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Scence.name)
  return name_;
}
inline ::std::string* Scence::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Scence::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Scence.name)
}

// repeated .Layer layers = 2;
inline int Scence::layers_size() const {
  return layers_.size();
}
inline void Scence::clear_layers() {
  layers_.Clear();
}
inline const ::Layer& Scence::layers(int index) const {
  // @@protoc_insertion_point(field_get:Scence.layers)
  return layers_.Get(index);
}
inline ::Layer* Scence::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:Scence.layers)
  return layers_.Mutable(index);
}
inline ::Layer* Scence::add_layers() {
  // @@protoc_insertion_point(field_add:Scence.layers)
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Layer >&
Scence::layers() const {
  // @@protoc_insertion_point(field_list:Scence.layers)
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::Layer >*
Scence::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:Scence.layers)
  return &layers_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_f_5fobject_2eproto__INCLUDED
