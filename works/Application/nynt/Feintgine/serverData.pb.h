// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: serverData.proto

#ifndef PROTOBUF_serverData_2eproto__INCLUDED
#define PROTOBUF_serverData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_serverData_2eproto();
void protobuf_AssignDesc_serverData_2eproto();
void protobuf_ShutdownFile_serverData_2eproto();

class Login;
class Register;
class PlayerMSG;
class CharacterLog;
class LogList;
class PlayerState;
class Login_Info;
class ClientCommand;
class Error;
class UDP_msg;
class TCP_msg;

// ===================================================================

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Login)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Register)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMSG : public ::google::protobuf::Message {
 public:
  PlayerMSG();
  virtual ~PlayerMSG();

  PlayerMSG(const PlayerMSG& from);

  inline PlayerMSG& operator=(const PlayerMSG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMSG& default_instance();

  void Swap(PlayerMSG* other);

  // implements Message ----------------------------------------------

  PlayerMSG* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMSG& from);
  void MergeFrom(const PlayerMSG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:PlayerMSG)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static PlayerMSG* default_instance_;
};
// -------------------------------------------------------------------

class CharacterLog : public ::google::protobuf::Message {
 public:
  CharacterLog();
  virtual ~CharacterLog();

  CharacterLog(const CharacterLog& from);

  inline CharacterLog& operator=(const CharacterLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterLog& default_instance();

  void Swap(CharacterLog* other);

  // implements Message ----------------------------------------------

  CharacterLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterLog& from);
  void MergeFrom(const CharacterLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // required float x_pos = 3;
  inline bool has_x_pos() const;
  inline void clear_x_pos();
  static const int kXPosFieldNumber = 3;
  inline float x_pos() const;
  inline void set_x_pos(float value);

  // required float y_pos = 4;
  inline bool has_y_pos() const;
  inline void clear_y_pos();
  static const int kYPosFieldNumber = 4;
  inline float y_pos() const;
  inline void set_y_pos(float value);

  // @@protoc_insertion_point(class_scope:CharacterLog)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_x_pos();
  inline void clear_has_x_pos();
  inline void set_has_y_pos();
  inline void clear_has_y_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* location_;
  float x_pos_;
  float y_pos_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static CharacterLog* default_instance_;
};
// -------------------------------------------------------------------

class LogList : public ::google::protobuf::Message {
 public:
  LogList();
  virtual ~LogList();

  LogList(const LogList& from);

  inline LogList& operator=(const LogList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogList& default_instance();

  void Swap(LogList* other);

  // implements Message ----------------------------------------------

  LogList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogList& from);
  void MergeFrom(const LogList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CharacterLog list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::CharacterLog& list(int index) const;
  inline ::CharacterLog* mutable_list(int index);
  inline ::CharacterLog* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::CharacterLog >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::CharacterLog >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:LogList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CharacterLog > list_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static LogList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerState : public ::google::protobuf::Message {
 public:
  PlayerState();
  virtual ~PlayerState();

  PlayerState(const PlayerState& from);

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerState& default_instance();

  void Swap(PlayerState* other);

  // implements Message ----------------------------------------------

  PlayerState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerState& from);
  void MergeFrom(const PlayerState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // required float x_pos = 3;
  inline bool has_x_pos() const;
  inline void clear_x_pos();
  static const int kXPosFieldNumber = 3;
  inline float x_pos() const;
  inline void set_x_pos(float value);

  // required float y_pos = 4;
  inline bool has_y_pos() const;
  inline void clear_y_pos();
  static const int kYPosFieldNumber = 4;
  inline float y_pos() const;
  inline void set_y_pos(float value);

  // @@protoc_insertion_point(class_scope:PlayerState)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_x_pos();
  inline void clear_has_x_pos();
  inline void set_has_y_pos();
  inline void clear_has_y_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 action_;
  float x_pos_;
  float y_pos_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static PlayerState* default_instance_;
};
// -------------------------------------------------------------------

class Login_Info : public ::google::protobuf::Message {
 public:
  Login_Info();
  virtual ~Login_Info();

  Login_Info(const Login_Info& from);

  inline Login_Info& operator=(const Login_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login_Info& default_instance();

  void Swap(Login_Info* other);

  // implements Message ----------------------------------------------

  Login_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login_Info& from);
  void MergeFrom(const Login_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:Login_Info)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static Login_Info* default_instance_;
};
// -------------------------------------------------------------------

class ClientCommand : public ::google::protobuf::Message {
 public:
  ClientCommand();
  virtual ~ClientCommand();

  ClientCommand(const ClientCommand& from);

  inline ClientCommand& operator=(const ClientCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientCommand& default_instance();

  void Swap(ClientCommand* other);

  // implements Message ----------------------------------------------

  ClientCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientCommand& from);
  void MergeFrom(const ClientCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:ClientCommand)
 private:
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static ClientCommand* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string des = 2;
  inline bool has_des() const;
  inline void clear_des();
  static const int kDesFieldNumber = 2;
  inline const ::std::string& des() const;
  inline void set_des(const ::std::string& value);
  inline void set_des(const char* value);
  inline void set_des(const char* value, size_t size);
  inline ::std::string* mutable_des();
  inline ::std::string* release_des();
  inline void set_allocated_des(::std::string* des);

  // @@protoc_insertion_point(class_scope:Error)
 private:
  inline void set_has_des();
  inline void clear_has_des();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* des_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class UDP_msg : public ::google::protobuf::Message {
 public:
  UDP_msg();
  virtual ~UDP_msg();

  UDP_msg(const UDP_msg& from);

  inline UDP_msg& operator=(const UDP_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UDP_msg& default_instance();

  void Swap(UDP_msg* other);

  // implements Message ----------------------------------------------

  UDP_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UDP_msg& from);
  void MergeFrom(const UDP_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .PlayerState m_playerState = 2;
  inline bool has_m_playerstate() const;
  inline void clear_m_playerstate();
  static const int kMPlayerStateFieldNumber = 2;
  inline const ::PlayerState& m_playerstate() const;
  inline ::PlayerState* mutable_m_playerstate();
  inline ::PlayerState* release_m_playerstate();
  inline void set_allocated_m_playerstate(::PlayerState* m_playerstate);

  // @@protoc_insertion_point(class_scope:UDP_msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_playerstate();
  inline void clear_has_m_playerstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PlayerState* m_playerstate_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static UDP_msg* default_instance_;
};
// -------------------------------------------------------------------

class TCP_msg : public ::google::protobuf::Message {
 public:
  TCP_msg();
  virtual ~TCP_msg();

  TCP_msg(const TCP_msg& from);

  inline TCP_msg& operator=(const TCP_msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCP_msg& default_instance();

  void Swap(TCP_msg* other);

  // implements Message ----------------------------------------------

  TCP_msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCP_msg& from);
  void MergeFrom(const TCP_msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .Login m_login = 2;
  inline bool has_m_login() const;
  inline void clear_m_login();
  static const int kMLoginFieldNumber = 2;
  inline const ::Login& m_login() const;
  inline ::Login* mutable_m_login();
  inline ::Login* release_m_login();
  inline void set_allocated_m_login(::Login* m_login);

  // optional .Register m_register = 3;
  inline bool has_m_register() const;
  inline void clear_m_register();
  static const int kMRegisterFieldNumber = 3;
  inline const ::Register& m_register() const;
  inline ::Register* mutable_m_register();
  inline ::Register* release_m_register();
  inline void set_allocated_m_register(::Register* m_register);

  // optional .PlayerMSG m_playerMSG = 4;
  inline bool has_m_playermsg() const;
  inline void clear_m_playermsg();
  static const int kMPlayerMSGFieldNumber = 4;
  inline const ::PlayerMSG& m_playermsg() const;
  inline ::PlayerMSG* mutable_m_playermsg();
  inline ::PlayerMSG* release_m_playermsg();
  inline void set_allocated_m_playermsg(::PlayerMSG* m_playermsg);

  // optional .ClientCommand m_clientCommand = 5;
  inline bool has_m_clientcommand() const;
  inline void clear_m_clientcommand();
  static const int kMClientCommandFieldNumber = 5;
  inline const ::ClientCommand& m_clientcommand() const;
  inline ::ClientCommand* mutable_m_clientcommand();
  inline ::ClientCommand* release_m_clientcommand();
  inline void set_allocated_m_clientcommand(::ClientCommand* m_clientcommand);

  // optional .Error m_error = 6;
  inline bool has_m_error() const;
  inline void clear_m_error();
  static const int kMErrorFieldNumber = 6;
  inline const ::Error& m_error() const;
  inline ::Error* mutable_m_error();
  inline ::Error* release_m_error();
  inline void set_allocated_m_error(::Error* m_error);

  // optional .LogList m_log_list = 7;
  inline bool has_m_log_list() const;
  inline void clear_m_log_list();
  static const int kMLogListFieldNumber = 7;
  inline const ::LogList& m_log_list() const;
  inline ::LogList* mutable_m_log_list();
  inline ::LogList* release_m_log_list();
  inline void set_allocated_m_log_list(::LogList* m_log_list);

  // optional .Login_Info m_log_info = 8;
  inline bool has_m_log_info() const;
  inline void clear_m_log_info();
  static const int kMLogInfoFieldNumber = 8;
  inline const ::Login_Info& m_log_info() const;
  inline ::Login_Info* mutable_m_log_info();
  inline ::Login_Info* release_m_log_info();
  inline void set_allocated_m_log_info(::Login_Info* m_log_info);

  // @@protoc_insertion_point(class_scope:TCP_msg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_m_login();
  inline void clear_has_m_login();
  inline void set_has_m_register();
  inline void clear_has_m_register();
  inline void set_has_m_playermsg();
  inline void clear_has_m_playermsg();
  inline void set_has_m_clientcommand();
  inline void clear_has_m_clientcommand();
  inline void set_has_m_error();
  inline void clear_has_m_error();
  inline void set_has_m_log_list();
  inline void clear_has_m_log_list();
  inline void set_has_m_log_info();
  inline void clear_has_m_log_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Login* m_login_;
  ::Register* m_register_;
  ::PlayerMSG* m_playermsg_;
  ::ClientCommand* m_clientcommand_;
  ::Error* m_error_;
  ::LogList* m_log_list_;
  ::Login_Info* m_log_info_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_serverData_2eproto();
  friend void protobuf_AssignDesc_serverData_2eproto();
  friend void protobuf_ShutdownFile_serverData_2eproto();

  void InitAsDefaultInstance();
  static TCP_msg* default_instance_;
};
// ===================================================================


// ===================================================================

// Login

// required string ID = 1;
inline bool Login::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Login::id() const {
  // @@protoc_insertion_point(field_get:Login.ID)
  return *id_;
}
inline void Login::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Login.ID)
}
inline void Login::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Login.ID)
}
inline void Login::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Login.ID)
}
inline ::std::string* Login::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Login.ID)
  return id_;
}
inline ::std::string* Login::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Login.ID)
}

// required string password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:Login.password)
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Login.password)
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Login.password)
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Login.password)
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Login.password)
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Login.password)
}

// -------------------------------------------------------------------

// Register

// required string ID = 1;
inline bool Register::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Register::id() const {
  // @@protoc_insertion_point(field_get:Register.ID)
  return *id_;
}
inline void Register::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Register.ID)
}
inline void Register::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Register.ID)
}
inline void Register::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Register.ID)
}
inline ::std::string* Register::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Register.ID)
  return id_;
}
inline ::std::string* Register::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Register::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Register.ID)
}

// required string password = 2;
inline bool Register::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Register::password() const {
  // @@protoc_insertion_point(field_get:Register.password)
  return *password_;
}
inline void Register::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Register.password)
}
inline void Register::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Register.password)
}
inline void Register::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Register.password)
}
inline ::std::string* Register::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Register.password)
  return password_;
}
inline ::std::string* Register::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Register::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Register.password)
}

// -------------------------------------------------------------------

// PlayerMSG

// required string name = 1;
inline bool PlayerMSG::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMSG::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMSG::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMSG::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerMSG::name() const {
  // @@protoc_insertion_point(field_get:PlayerMSG.name)
  return *name_;
}
inline void PlayerMSG::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerMSG.name)
}
inline void PlayerMSG::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerMSG.name)
}
inline void PlayerMSG::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerMSG.name)
}
inline ::std::string* PlayerMSG::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerMSG.name)
  return name_;
}
inline ::std::string* PlayerMSG::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerMSG::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerMSG.name)
}

// required string msg = 2;
inline bool PlayerMSG::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMSG::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMSG::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMSG::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& PlayerMSG::msg() const {
  // @@protoc_insertion_point(field_get:PlayerMSG.msg)
  return *msg_;
}
inline void PlayerMSG::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerMSG.msg)
}
inline void PlayerMSG::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerMSG.msg)
}
inline void PlayerMSG::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerMSG.msg)
}
inline ::std::string* PlayerMSG::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerMSG.msg)
  return msg_;
}
inline ::std::string* PlayerMSG::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerMSG::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerMSG.msg)
}

// -------------------------------------------------------------------

// CharacterLog

// required string name = 1;
inline bool CharacterLog::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterLog::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterLog::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterLog::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CharacterLog::name() const {
  // @@protoc_insertion_point(field_get:CharacterLog.name)
  return *name_;
}
inline void CharacterLog::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:CharacterLog.name)
}
inline void CharacterLog::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:CharacterLog.name)
}
inline void CharacterLog::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CharacterLog.name)
}
inline ::std::string* CharacterLog::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CharacterLog.name)
  return name_;
}
inline ::std::string* CharacterLog::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CharacterLog::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CharacterLog.name)
}

// required string location = 2;
inline bool CharacterLog::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterLog::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterLog::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterLog::clear_location() {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& CharacterLog::location() const {
  // @@protoc_insertion_point(field_get:CharacterLog.location)
  return *location_;
}
inline void CharacterLog::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set:CharacterLog.location)
}
inline void CharacterLog::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set_char:CharacterLog.location)
}
inline void CharacterLog::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CharacterLog.location)
}
inline ::std::string* CharacterLog::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:CharacterLog.location)
  return location_;
}
inline ::std::string* CharacterLog::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CharacterLog::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:CharacterLog.location)
}

// required float x_pos = 3;
inline bool CharacterLog::has_x_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharacterLog::set_has_x_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharacterLog::clear_has_x_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharacterLog::clear_x_pos() {
  x_pos_ = 0;
  clear_has_x_pos();
}
inline float CharacterLog::x_pos() const {
  // @@protoc_insertion_point(field_get:CharacterLog.x_pos)
  return x_pos_;
}
inline void CharacterLog::set_x_pos(float value) {
  set_has_x_pos();
  x_pos_ = value;
  // @@protoc_insertion_point(field_set:CharacterLog.x_pos)
}

// required float y_pos = 4;
inline bool CharacterLog::has_y_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharacterLog::set_has_y_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharacterLog::clear_has_y_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharacterLog::clear_y_pos() {
  y_pos_ = 0;
  clear_has_y_pos();
}
inline float CharacterLog::y_pos() const {
  // @@protoc_insertion_point(field_get:CharacterLog.y_pos)
  return y_pos_;
}
inline void CharacterLog::set_y_pos(float value) {
  set_has_y_pos();
  y_pos_ = value;
  // @@protoc_insertion_point(field_set:CharacterLog.y_pos)
}

// -------------------------------------------------------------------

// LogList

// repeated .CharacterLog list = 1;
inline int LogList::list_size() const {
  return list_.size();
}
inline void LogList::clear_list() {
  list_.Clear();
}
inline const ::CharacterLog& LogList::list(int index) const {
  // @@protoc_insertion_point(field_get:LogList.list)
  return list_.Get(index);
}
inline ::CharacterLog* LogList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:LogList.list)
  return list_.Mutable(index);
}
inline ::CharacterLog* LogList::add_list() {
  // @@protoc_insertion_point(field_add:LogList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CharacterLog >&
LogList::list() const {
  // @@protoc_insertion_point(field_list:LogList.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::CharacterLog >*
LogList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:LogList.list)
  return &list_;
}

// -------------------------------------------------------------------

// PlayerState

// required string name = 1;
inline bool PlayerState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerState::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerState::name() const {
  // @@protoc_insertion_point(field_get:PlayerState.name)
  return *name_;
}
inline void PlayerState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:PlayerState.name)
}
inline void PlayerState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PlayerState.name)
}
inline void PlayerState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PlayerState.name)
}
inline ::std::string* PlayerState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PlayerState.name)
  return name_;
}
inline ::std::string* PlayerState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlayerState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PlayerState.name)
}

// required int32 action = 2;
inline bool PlayerState::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerState::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerState::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerState::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 PlayerState::action() const {
  // @@protoc_insertion_point(field_get:PlayerState.action)
  return action_;
}
inline void PlayerState::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:PlayerState.action)
}

// required float x_pos = 3;
inline bool PlayerState::has_x_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerState::set_has_x_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerState::clear_has_x_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerState::clear_x_pos() {
  x_pos_ = 0;
  clear_has_x_pos();
}
inline float PlayerState::x_pos() const {
  // @@protoc_insertion_point(field_get:PlayerState.x_pos)
  return x_pos_;
}
inline void PlayerState::set_x_pos(float value) {
  set_has_x_pos();
  x_pos_ = value;
  // @@protoc_insertion_point(field_set:PlayerState.x_pos)
}

// required float y_pos = 4;
inline bool PlayerState::has_y_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerState::set_has_y_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerState::clear_has_y_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerState::clear_y_pos() {
  y_pos_ = 0;
  clear_has_y_pos();
}
inline float PlayerState::y_pos() const {
  // @@protoc_insertion_point(field_get:PlayerState.y_pos)
  return y_pos_;
}
inline void PlayerState::set_y_pos(float value) {
  set_has_y_pos();
  y_pos_ = value;
  // @@protoc_insertion_point(field_set:PlayerState.y_pos)
}

// -------------------------------------------------------------------

// Login_Info

// required string ID = 1;
inline bool Login_Info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login_Info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login_Info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login_Info::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Login_Info::id() const {
  // @@protoc_insertion_point(field_get:Login_Info.ID)
  return *id_;
}
inline void Login_Info::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Login_Info.ID)
}
inline void Login_Info::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Login_Info.ID)
}
inline void Login_Info::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Login_Info.ID)
}
inline ::std::string* Login_Info::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Login_Info.ID)
  return id_;
}
inline ::std::string* Login_Info::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Login_Info::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Login_Info.ID)
}

// -------------------------------------------------------------------

// ClientCommand

// required string command = 1;
inline bool ClientCommand::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientCommand::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientCommand::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& ClientCommand::command() const {
  // @@protoc_insertion_point(field_get:ClientCommand.command)
  return *command_;
}
inline void ClientCommand::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:ClientCommand.command)
}
inline void ClientCommand::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:ClientCommand.command)
}
inline void ClientCommand::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ClientCommand.command)
}
inline ::std::string* ClientCommand::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ClientCommand.command)
  return command_;
}
inline ::std::string* ClientCommand::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientCommand::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ClientCommand.command)
}

// -------------------------------------------------------------------

// Error

// required string des = 2;
inline bool Error::has_des() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_des() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_des() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_des() {
  if (des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_->clear();
  }
  clear_has_des();
}
inline const ::std::string& Error::des() const {
  // @@protoc_insertion_point(field_get:Error.des)
  return *des_;
}
inline void Error::set_des(const ::std::string& value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(value);
  // @@protoc_insertion_point(field_set:Error.des)
}
inline void Error::set_des(const char* value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(value);
  // @@protoc_insertion_point(field_set_char:Error.des)
}
inline void Error::set_des(const char* value, size_t size) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  des_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Error.des)
}
inline ::std::string* Error::mutable_des() {
  set_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    des_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Error.des)
  return des_;
}
inline ::std::string* Error::release_des() {
  clear_has_des();
  if (des_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = des_;
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Error::set_allocated_des(::std::string* des) {
  if (des_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete des_;
  }
  if (des) {
    set_has_des();
    des_ = des;
  } else {
    clear_has_des();
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Error.des)
}

// -------------------------------------------------------------------

// UDP_msg

// required int32 type = 1;
inline bool UDP_msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UDP_msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UDP_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UDP_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UDP_msg::type() const {
  // @@protoc_insertion_point(field_get:UDP_msg.type)
  return type_;
}
inline void UDP_msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:UDP_msg.type)
}

// optional .PlayerState m_playerState = 2;
inline bool UDP_msg::has_m_playerstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UDP_msg::set_has_m_playerstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UDP_msg::clear_has_m_playerstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UDP_msg::clear_m_playerstate() {
  if (m_playerstate_ != NULL) m_playerstate_->::PlayerState::Clear();
  clear_has_m_playerstate();
}
inline const ::PlayerState& UDP_msg::m_playerstate() const {
  // @@protoc_insertion_point(field_get:UDP_msg.m_playerState)
  return m_playerstate_ != NULL ? *m_playerstate_ : *default_instance_->m_playerstate_;
}
inline ::PlayerState* UDP_msg::mutable_m_playerstate() {
  set_has_m_playerstate();
  if (m_playerstate_ == NULL) m_playerstate_ = new ::PlayerState;
  // @@protoc_insertion_point(field_mutable:UDP_msg.m_playerState)
  return m_playerstate_;
}
inline ::PlayerState* UDP_msg::release_m_playerstate() {
  clear_has_m_playerstate();
  ::PlayerState* temp = m_playerstate_;
  m_playerstate_ = NULL;
  return temp;
}
inline void UDP_msg::set_allocated_m_playerstate(::PlayerState* m_playerstate) {
  delete m_playerstate_;
  m_playerstate_ = m_playerstate;
  if (m_playerstate) {
    set_has_m_playerstate();
  } else {
    clear_has_m_playerstate();
  }
  // @@protoc_insertion_point(field_set_allocated:UDP_msg.m_playerState)
}

// -------------------------------------------------------------------

// TCP_msg

// required int32 type = 1;
inline bool TCP_msg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCP_msg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCP_msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCP_msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TCP_msg::type() const {
  // @@protoc_insertion_point(field_get:TCP_msg.type)
  return type_;
}
inline void TCP_msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TCP_msg.type)
}

// optional .Login m_login = 2;
inline bool TCP_msg::has_m_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCP_msg::set_has_m_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCP_msg::clear_has_m_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCP_msg::clear_m_login() {
  if (m_login_ != NULL) m_login_->::Login::Clear();
  clear_has_m_login();
}
inline const ::Login& TCP_msg::m_login() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_login)
  return m_login_ != NULL ? *m_login_ : *default_instance_->m_login_;
}
inline ::Login* TCP_msg::mutable_m_login() {
  set_has_m_login();
  if (m_login_ == NULL) m_login_ = new ::Login;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_login)
  return m_login_;
}
inline ::Login* TCP_msg::release_m_login() {
  clear_has_m_login();
  ::Login* temp = m_login_;
  m_login_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_login(::Login* m_login) {
  delete m_login_;
  m_login_ = m_login;
  if (m_login) {
    set_has_m_login();
  } else {
    clear_has_m_login();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_login)
}

// optional .Register m_register = 3;
inline bool TCP_msg::has_m_register() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCP_msg::set_has_m_register() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCP_msg::clear_has_m_register() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCP_msg::clear_m_register() {
  if (m_register_ != NULL) m_register_->::Register::Clear();
  clear_has_m_register();
}
inline const ::Register& TCP_msg::m_register() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_register)
  return m_register_ != NULL ? *m_register_ : *default_instance_->m_register_;
}
inline ::Register* TCP_msg::mutable_m_register() {
  set_has_m_register();
  if (m_register_ == NULL) m_register_ = new ::Register;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_register)
  return m_register_;
}
inline ::Register* TCP_msg::release_m_register() {
  clear_has_m_register();
  ::Register* temp = m_register_;
  m_register_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_register(::Register* m_register) {
  delete m_register_;
  m_register_ = m_register;
  if (m_register) {
    set_has_m_register();
  } else {
    clear_has_m_register();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_register)
}

// optional .PlayerMSG m_playerMSG = 4;
inline bool TCP_msg::has_m_playermsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCP_msg::set_has_m_playermsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCP_msg::clear_has_m_playermsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCP_msg::clear_m_playermsg() {
  if (m_playermsg_ != NULL) m_playermsg_->::PlayerMSG::Clear();
  clear_has_m_playermsg();
}
inline const ::PlayerMSG& TCP_msg::m_playermsg() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_playerMSG)
  return m_playermsg_ != NULL ? *m_playermsg_ : *default_instance_->m_playermsg_;
}
inline ::PlayerMSG* TCP_msg::mutable_m_playermsg() {
  set_has_m_playermsg();
  if (m_playermsg_ == NULL) m_playermsg_ = new ::PlayerMSG;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_playerMSG)
  return m_playermsg_;
}
inline ::PlayerMSG* TCP_msg::release_m_playermsg() {
  clear_has_m_playermsg();
  ::PlayerMSG* temp = m_playermsg_;
  m_playermsg_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_playermsg(::PlayerMSG* m_playermsg) {
  delete m_playermsg_;
  m_playermsg_ = m_playermsg;
  if (m_playermsg) {
    set_has_m_playermsg();
  } else {
    clear_has_m_playermsg();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_playerMSG)
}

// optional .ClientCommand m_clientCommand = 5;
inline bool TCP_msg::has_m_clientcommand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCP_msg::set_has_m_clientcommand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCP_msg::clear_has_m_clientcommand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCP_msg::clear_m_clientcommand() {
  if (m_clientcommand_ != NULL) m_clientcommand_->::ClientCommand::Clear();
  clear_has_m_clientcommand();
}
inline const ::ClientCommand& TCP_msg::m_clientcommand() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_clientCommand)
  return m_clientcommand_ != NULL ? *m_clientcommand_ : *default_instance_->m_clientcommand_;
}
inline ::ClientCommand* TCP_msg::mutable_m_clientcommand() {
  set_has_m_clientcommand();
  if (m_clientcommand_ == NULL) m_clientcommand_ = new ::ClientCommand;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_clientCommand)
  return m_clientcommand_;
}
inline ::ClientCommand* TCP_msg::release_m_clientcommand() {
  clear_has_m_clientcommand();
  ::ClientCommand* temp = m_clientcommand_;
  m_clientcommand_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_clientcommand(::ClientCommand* m_clientcommand) {
  delete m_clientcommand_;
  m_clientcommand_ = m_clientcommand;
  if (m_clientcommand) {
    set_has_m_clientcommand();
  } else {
    clear_has_m_clientcommand();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_clientCommand)
}

// optional .Error m_error = 6;
inline bool TCP_msg::has_m_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TCP_msg::set_has_m_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TCP_msg::clear_has_m_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TCP_msg::clear_m_error() {
  if (m_error_ != NULL) m_error_->::Error::Clear();
  clear_has_m_error();
}
inline const ::Error& TCP_msg::m_error() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_error)
  return m_error_ != NULL ? *m_error_ : *default_instance_->m_error_;
}
inline ::Error* TCP_msg::mutable_m_error() {
  set_has_m_error();
  if (m_error_ == NULL) m_error_ = new ::Error;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_error)
  return m_error_;
}
inline ::Error* TCP_msg::release_m_error() {
  clear_has_m_error();
  ::Error* temp = m_error_;
  m_error_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_error(::Error* m_error) {
  delete m_error_;
  m_error_ = m_error;
  if (m_error) {
    set_has_m_error();
  } else {
    clear_has_m_error();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_error)
}

// optional .LogList m_log_list = 7;
inline bool TCP_msg::has_m_log_list() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TCP_msg::set_has_m_log_list() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TCP_msg::clear_has_m_log_list() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TCP_msg::clear_m_log_list() {
  if (m_log_list_ != NULL) m_log_list_->::LogList::Clear();
  clear_has_m_log_list();
}
inline const ::LogList& TCP_msg::m_log_list() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_log_list)
  return m_log_list_ != NULL ? *m_log_list_ : *default_instance_->m_log_list_;
}
inline ::LogList* TCP_msg::mutable_m_log_list() {
  set_has_m_log_list();
  if (m_log_list_ == NULL) m_log_list_ = new ::LogList;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_log_list)
  return m_log_list_;
}
inline ::LogList* TCP_msg::release_m_log_list() {
  clear_has_m_log_list();
  ::LogList* temp = m_log_list_;
  m_log_list_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_log_list(::LogList* m_log_list) {
  delete m_log_list_;
  m_log_list_ = m_log_list;
  if (m_log_list) {
    set_has_m_log_list();
  } else {
    clear_has_m_log_list();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_log_list)
}

// optional .Login_Info m_log_info = 8;
inline bool TCP_msg::has_m_log_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TCP_msg::set_has_m_log_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TCP_msg::clear_has_m_log_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TCP_msg::clear_m_log_info() {
  if (m_log_info_ != NULL) m_log_info_->::Login_Info::Clear();
  clear_has_m_log_info();
}
inline const ::Login_Info& TCP_msg::m_log_info() const {
  // @@protoc_insertion_point(field_get:TCP_msg.m_log_info)
  return m_log_info_ != NULL ? *m_log_info_ : *default_instance_->m_log_info_;
}
inline ::Login_Info* TCP_msg::mutable_m_log_info() {
  set_has_m_log_info();
  if (m_log_info_ == NULL) m_log_info_ = new ::Login_Info;
  // @@protoc_insertion_point(field_mutable:TCP_msg.m_log_info)
  return m_log_info_;
}
inline ::Login_Info* TCP_msg::release_m_log_info() {
  clear_has_m_log_info();
  ::Login_Info* temp = m_log_info_;
  m_log_info_ = NULL;
  return temp;
}
inline void TCP_msg::set_allocated_m_log_info(::Login_Info* m_log_info) {
  delete m_log_info_;
  m_log_info_ = m_log_info;
  if (m_log_info) {
    set_has_m_log_info();
  } else {
    clear_has_m_log_info();
  }
  // @@protoc_insertion_point(field_set_allocated:TCP_msg.m_log_info)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_serverData_2eproto__INCLUDED
